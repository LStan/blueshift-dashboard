import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Квантове сховище

![Завдання Pinocchio Quantum Vault](/graphics/challenge-banners/pinocchio-quantum-vault.png)

Сховище є фундаментальним будівельним блоком у DeFi, який забезпечує безпечний спосіб зберігання активів для користувачів.

У цьому завданні ми створимо сховище, яке використовує підписи Вінтерніца для перевірки транзакцій. Це особливо цікаво, оскільки підпис Вінтерніца є першим постквантовим підписом, інтегрованим у Solana.

> Якщо ви не знайомі з підписом Вінтерніца, почніть з читання [Підпис Вінтерніца на Solana](/uk/courses/winternitz-signatures-on-solana), щоб зрозуміти основні концепції та базову криптографію.

У цьому завданні ми оновимо просте сховище lamport, яке ми створили в [Завданні Pinocchio Vault](/uk/challenges/pinocchio-vault), щоб дозволити використання підписів Вінтерніца як метод перевірки для транзакцій.

<ArticleSection name="Installation" id="installation" level="h2" />

Перш ніж почати, переконайтеся, що Rust і Pinocchio встановлені. Потім виконайте наступне у вашому терміналі:

```bash
# create workspace
cargo new blueshift-pinocchio-quantum-vault --lib --edition 2021
cd blueshift-pinocchio-quantum-vault
```

Додайте `pinocchio`, `pinocchio-system`, `solana-nostd-sha256` та `solana-winternitz`:

```bash
cargo add pinocchio pinocchio-system solana-nostd-sha256 solana-winternitz
```

Оголосіть типи крейту в `Cargo.toml`, щоб згенерувати артефакти розгортання в `target/deploy`:

```toml
[lib]
crate-type = ["lib", "cdylib"]
```

Тепер ви готові написати вашу програму квантового сховища.

<ArticleSection name="Template" id="template" level="h2" />

Цього разу ми розділимо програму на маленькі, сфокусовані модулі замість того, щоб розміщувати все в `lib.rs`. Дерево папок буде виглядати приблизно так:

```
src
├── instructions
│       ├── close.rs
│       ├── open.rs
│       ├── mod.rs
│       └── split.rs
└── lib.rs
```

**Примітка**: Не забудьте змінити ID програми на `22222222222222222222222222222222222222222222`, оскільки ми використовуємо його під капотом для тестування вашої програми.

Точка входу в `lib.rs` дуже схожа на те, що ми розглядали в [Вступі до курсу Pinocchio](/uk/courses/introduction-to-pinocchio).

```rust
pub mod instructions;
use instructions::*;

use pinocchio::{
    account_info::AccountInfo, program_entrypoint, program_error::ProgramError,
    pubkey::Pubkey, ProgramResult,
};

program_entrypoint!(process_instruction);

// 22222222222222222222222222222222222222222222
pub const ID: Pubkey = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {    
    match instruction_data.split_first() {
        Some((OpenVault::DISCRIMINATOR, data)) => OpenVault::try_from((data, accounts))?.process(),
        Some((SplitVault::DISCRIMINATOR, data)) => SplitVault::try_from((data, accounts))?.process(),
        Some((CloseVault::DISCRIMINATOR, data)) => CloseVault::try_from((data, accounts))?.process(),
        _ => Err(ProgramError::InvalidInstructionData)
    }
}
```

Нам не потрібно налаштовувати стан для цього, тому ми просто перейдемо до створення наших інструкцій.