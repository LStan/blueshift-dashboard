import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# The Escrow

An escrow is a powerful financial tool that enables secure token swaps between two parties. 

Think of it as a digital safe deposit box where one user can lock up Token A, waiting for another user to deposit Token B before the swap is completed. 

This creates a trustless environment where neither party needs to worry about the other backing out of the deal.

In this challenge, we're going to implement this concept through three simple but powerful instructions:
- **Make**: The maker (first user) defines the trade terms and deposits the agreed amount of Token A into a secure vault. This is like putting your item in the safe deposit box and setting the terms of the exchange.
- **Take**: The taker (second user) accepts the offer by transferring the promised amount of Token B to the maker, and in return, receives the locked Token A. This is the moment when both parties complete their side of the deal.
- **Refund**: If the maker changes their mind or no suitable taker is found, they can cancel the offer and retrieve their Token A. This is like getting your item back from the safe deposit box if the deal falls through.

**Note**: If you're not familiar with Pinocchio, you should start by reading the [Introduction to Pinocchio](learn.blueshift.gg/en/courses/introduction-to-pinocchio) to familiarize with the core concepts that we're going to use in this program.

<ArticleSection name="Installation" id="installation" level="h2" />

Let's start by creating a fresh Rust environment:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

Add pinocchio, pinocchio-system, pinocchio-token and pinocchio-associated-token:

```
cargo add pinocchio pinocchio-system pinocchio-token pinocchio-associated-token-account
```

Declare the crate types in `Cargo.toml` to generate deployment artifacts in `target/deploy`:

```
[lib]
crate-type = ["lib", "cdylib"]
```

You're now ready to write your escrow program.

<ArticleSection name="Template" id="template" level="h2" />

This time we'll split the program into small, focused modules instead of cramming everything into the `lib.rs`. The folder tree will look roughly like this:

```
src
├── instructions
│       ├── make.rs
│       ├── helpers.rs
│       ├── mod.rs
│       ├── refund.rs
│       └── take.rs
├── errors.rs
├── lib.rs
└── state.rs
```

The entrypoint, that lives in the `lib.rs` looks very similar to what we did in the last lessons so we're going to go over it very quickly:

<Codeblock lang="rust">
```rust
use pinocchio::{account_info::AccountInfo, entrypoint, program_error::ProgramError, pubkey::Pubkey, ProgramResult};
entrypoint!(process_instruction);

pub mod instructions;
pub use instructions::*;

pub mod state;
pub use state::*;

// 22222222222222222222222222222222222222222222
pub const ID: Pubkey = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07,
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee,
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07,
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7,
];

fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    match instruction_data.split_first() {
        Some((Make::DISCRIMINATOR, data)) => Make::try_from((data, accounts))?.process(),
        Some((Take::DISCRIMINATOR, _)) => Take::try_from(accounts)?.process(),
        Some((Refund::DISCRIMINATOR, _)) => Refund::try_from(accounts)?.process(),
        _ => Err(ProgramError::InvalidInstructionData)
    }
}
```
</Codeblock>

<ArticleSection name="State" id="state" level="h2" />

We're going to move into the `state.rs` where all the data for our `Escrow` lives. Let's break this down into two parts: the struct definition and its implementation.

First, let's look at the struct definition:

<Codeblock lang="rust">
```rust
use pinocchio::{account_info::{AccountInfo, Ref}, program_error::ProgramError, pubkey::Pubkey};
use core::mem::size_of;

#[repr(C)]
pub struct Escrow {
    pub seed: u64,        // Random seed for PDA derivation
    pub maker: Pubkey,    // Creator of the escrow
    pub mint_a: Pubkey,   // Token being deposited
    pub mint_b: Pubkey,   // Token being requested
    pub receive: u64,     // Amount of token B wanted
    pub bump: [u8;1]      // PDA bump seed
}
```
</Codeblock>

The `#[repr(C)]` attribute ensures our struct has a predictable memory layout, which is crucial for on-chain data. Each field serves a specific purpose:
- **seed**: A random number that allows one maker to create multiple escrows with the same token pair
- **maker**: The wallet address that created the escrow and will receive the tokens
- **mint_a**: The SPL token mint address for the token being deposited
- **mint_b**: The SPL token mint address for the token being requested
- **receive**: The exact amount of token B that the maker wants to receive
- **bump**: A single byte used in PDA derivation to ensure the address is on the ed25519 curve

Now, let's look at the implementation with all its helper methods:

<Codeblock lang="rust">
```rust
impl Escrow {
    /// The length of the `Escrow` account data.
    /// This is calculated by summing the size of each field:
    /// - seed: 8 bytes (u64)
    /// - maker: 32 bytes (Pubkey)
    /// - mint_a: 32 bytes (Pubkey)
    /// - mint_b: 32 bytes (Pubkey)
    /// - receive: 8 bytes (u64)
    /// - bump: 1 byte ([u8;1])
    pub const LEN: usize = size_of::<u64>() 
        + size_of::<Pubkey>() 
        + size_of::<Pubkey>() 
        + size_of::<Pubkey>() 
        + size_of::<u64>()
        + size_of::<[u8;1]>();

    /// Safely loads an Escrow from an AccountInfo.
    /// Performs validation checks:
    /// 1. Verifies the account data length matches our struct
    /// 2. Confirms the account is owned by our program
    /// 3. Safely borrows the data
    #[inline]
    pub fn from_account_info(account_info: &AccountInfo) -> Result<Ref<Escrow>, ProgramError> {
        if account_info.data_len() != Self::LEN {
            return Err(ProgramError::InvalidAccountData);
        }
        if account_info.owner() != &crate::ID {
            return Err(ProgramError::InvalidAccountOwner);
        }
        Ok(Ref::map(account_info.try_borrow_data()?, |data| unsafe {
            Self::from_bytes(data)
        }))
    }

    /// Unsafe version of from_account_info.
    /// Use this when you're certain there are no mutable borrows of the account data.
    /// Still performs length and owner validation.
    #[inline]
    pub unsafe fn from_account_info_unchecked(
        account_info: &AccountInfo,
    ) -> Result<&Self, ProgramError> {
        if account_info.data_len() != Self::LEN {
            return Err(ProgramError::InvalidAccountData);
        }
        if account_info.owner() != &crate::ID {
            return Err(ProgramError::InvalidAccountOwner);
        }
        Ok(Self::from_bytes(account_info.borrow_data_unchecked()))
    }

    /// Converts raw bytes into an Escrow reference.
    /// This is unsafe because it assumes the bytes are properly formatted.
    #[inline(always)]
    pub unsafe fn from_bytes(bytes: &[u8]) -> &Self {
        &*(bytes.as_ptr() as *const Escrow)
    }

    /// Sets all fields of the Escrow at once.
    /// This is more efficient than setting fields individually.
    #[inline(always)]
    pub fn set_inner(&mut self, seed: u64, maker: Pubkey, mint_a: Pubkey, mint_b: Pubkey, receive: u64, bump: [u8;1]) {
        self.seed = seed;
        self.maker = maker;
        self.mint_a = mint_a;
        self.mint_b = mint_b;
        self.receive = receive;
        self.bump = bump;
    }

    // Getters for all fields
    // These are marked #[inline(always)] for maximum performance
    // since they're called frequently in our program

    #[inline(always)]
    pub fn seed(&self) -> &u64 {
        &self.seed
    }

    #[inline(always)]
    pub fn maker(&self) -> &Pubkey {
        &self.maker
    }

    #[inline(always)]
    pub fn mint_a(&self) -> &Pubkey {
        &self.mint_a
    }

    #[inline(always)]
    pub fn mint_b(&self) -> &Pubkey {
        &self.mint_b
    }

    #[inline(always)]
    pub fn receive(&self) -> &u64 {
        &self.receive
    }

    #[inline(always)]
    pub fn bump(&self) -> &[u8;1] {
        &self.bump
    }
}
```
</Codeblock>

The implementation provides several key features:
1. **Exact Size Calculation**: `LEN` precisely calculates the account size by summing each field's size
2. **Safe Loading**: `from_account_info` provides a safe way to load and validate escrow data
3. **Performance Optimizations**: 
   - `#[inline(always)]` on getters for maximum performance
   - Unsafe methods for when we know the borrow is safe
   - Efficient field setting with `set_inner`
4. **Memory Safety**: Proper validation of account data length and ownership
5. **Documentation**: Clear comments explaining the purpose and safety considerations of each method

This implementation ensures our escrow state is both safe and efficient, with proper validation and performance optimizations where appropriate.

<ArticleSection name="Make" id="make" level="h2" />

The `make` instruction does three jobs:
- Initialises the Escrow record and stores all deal terms.
- Creates the Vault (an ATA for `mint_a` owned by the `escrow`).
- Moves the maker's Token A into that vault with a CPI to the SPL-Token program.

### Required Accounts

Below are the accounts the context needs:

- maker: the creator of the escrow. Must be a signer and mutable
- escrow: the escrow account that we're initializing. Must be mutable
- mint_a: the token we're depositing in the escrow
- mint_b: the token we want to receive
- maker_ata_a: the associated token account owned by the maker. Must be mutable
- vault: the associated token account owned by the escrow. Must be mutable
- associated_token_program: the associated token program. Must be executable
- token_program: the token program. Must be executable
- system_program: the system program. Must be executable

We're going to use the types that live in the `helper.rs` file that we discussed in the previous section.

In code, this looks like:

<Codeblock lang="rust">
```rust
pub struct MakeAccounts<'a> {
    pub maker: &'a AccountInfo,
    pub escrow: &'a AccountInfo,
    pub mint_a: &'a AccountInfo,
    pub mint_b: &'a AccountInfo,
    pub maker_ata_a: &'a AccountInfo,
    pub vault: &'a AccountInfo,
    pub system_program: &'a AccountInfo,
    pub token_program: &'a AccountInfo,
}

impl<'a> TryFrom<&'a [AccountInfo]> for MakeAccounts<'a> {
    type Error = ProgramError;

    fn try_from(accounts: &'a [AccountInfo]) -> Result<Self, Self::Error> {
        let [maker, escrow, mint_a, mint_b, maker_ata_a, vault, system_program, token_program, _] = accounts else {
            return Err(ProgramError::NotEnoughAccountKeys);
        };

        // Basic Accounts Checks
        SignerAccount::check(maker)?;
        MintInterface::check(mint_a)?;
        MintInterface::check(mint_b)?;
        AssociatedTokenAccount::check(maker_ata_a, maker, mint_a, token_program)?;

        // Return the accounts
        Ok(Self {
            maker,
            escrow,
            mint_a,
            mint_b,
            maker_ata_a,
            vault,
            system_program,
            token_program,
        })
    }
}
```
</Codeblock>

### Instruction Data

Here's the instruction data we need to pass in:
- seed: the random number used during seed derivation. Must be a u64
- receive: the amount that the maker wants to receive. Must be a u64
- amount: the amount that the maker wants to deposit. Must be a u64

We'll check to make sure the `amount` isn't zero, since that wouldn't make sense for an escrow.

Here's how it looks in code:

<Codeblock lang="rust">
```rust
pub struct MakeInstructionData {
    pub seed: u64,
    pub receive: u64,
    pub amount: u64,
}

impl<'a> TryFrom<&'a [u8]> for MakeInstructionData {
    type Error = ProgramError;

    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        if data.len() != size_of::<u64>() * 3 {
            return Err(ProgramError::InvalidInstructionData);
        }

        let seed = u64::from_le_bytes(data[0..8].try_into().unwrap());
        let receive = u64::from_le_bytes(data[8..16].try_into().unwrap());
        let amount = u64::from_le_bytes(data[16..24].try_into().unwrap());

        // Instruction Checks
        if amount == 0 {
            return Err(ProgramError::InvalidInstructionData);
        }

        Ok(Self {
            seed,
            receive,
            amount,
        })
    }
}
```
</Codeblock>

### Instruction Logic

The implementation follows a clear sequence:

1. **Account Validation**: First, we validate all accounts to ensure they're correct and have the right permissions
2. **PDA Derivation**: We derive the escrow's address using the maker's pubkey and seed
3. **Account Initialization**: We create both the escrow and vault accounts
4. **State Setup**: We populate the escrow account with all the trade terms
5. **Token Transfer**: Finally, we move the maker's tokens into the vault

<ArticleSection name="Take" id="take" level="h2" />

The `take` instruction finalizes the swap:
- Close the escrow record, sending its rent lamports back to the maker.
- Move Token A from the vault to the taker, then close the vault.
- Move the agreed amount of Token B from the taker to the maker.

### Required Accounts

Similarly these are all the accounts needed for the `Take` context:

Below are the accounts the context needs:

- taker: the person that wants to take the deal. Must be a signer and mutable.
- maker: the creator of the escrow. Must be mutable.
- escrow: the escrow account that we're initializing. Must be mutable.
- mint_a: the token we're depositing in the escrow
- mint_b: the token we want to receive
- vault: the associated token account owned by the escrow. Must be mutable
- taker_ata_a: the associated token account owned by the taker for mint_a. Must be mutable
- maker_ata_b: the associated token account owned by the maker for mint_b. Must be mutable
- taker_ata_b: the associated token account owned by the taker for mint_b. Must be mutable
- associated_token_program: the associated token program. Must be executable
- token_program: the token program. Must be executable
- system_program: the system program. Must be executable

And we perform these checks on it:

<Codeblock lang="rust">
```rust
pub struct TakeAccounts<'a> {
    pub taker: &'a AccountInfo,
    pub maker: &'a AccountInfo,
    pub escrow: &'a AccountInfo,
    pub mint_a: &'a AccountInfo,
    pub mint_b: &'a AccountInfo,
    pub vault: &'a AccountInfo,
    pub taker_ata_a: &'a AccountInfo,
    pub taker_ata_b: &'a AccountInfo,
    pub maker_ata_b: &'a AccountInfo,
    pub system_program: &'a AccountInfo,
    pub token_program: &'a AccountInfo,
}

impl<'a> TryFrom<&'a [AccountInfo]> for TakeAccounts<'a> {
    type Error = ProgramError;

    fn try_from(accounts: &'a [AccountInfo]) -> Result<Self, Self::Error> {
        let [taker, maker, escrow, mint_a, mint_b, vault, taker_ata_a, taker_ata_b, maker_ata_b, system_program, token_program, _] = accounts else {
            return Err(ProgramError::NotEnoughAccountKeys);
        };

        // Basic Accounts Checks
        SignerAccount::check(taker)?;
        ProgramAccount::check(escrow)?;
        MintInterface::check(mint_a)?;
        MintInterface::check(mint_b)?;
        AssociatedTokenAccount::check(taker_ata_b, taker, mint_b, token_program)?;
        AssociatedTokenAccount::check(vault, escrow, mint_a, token_program)?;

        // Return the accounts
        Ok(Self {
            taker,
            maker,
            escrow,
            mint_a,
            mint_b,
            taker_ata_a,
            taker_ata_b,
            maker_ata_b,
            vault,
            system_program,
            token_program,
        })
    }
}
```
</Codeblock>

### Instruction Data

All the data that we need to perform the logic already lives in the Escrow account or on the accounts that we're deserializing. For this reason we don't need any `instruction_data` for this instruction.

### Logic

1. **Escrow Validation**: 
   - Verify the escrow's PDA derivation
   - Check that all terms are valid
   - Ensure the taker has enough tokens

2. **Token A Transfer**:
   - Move tokens from vault to taker
   - Close the vault account
   - Return rent to maker

3. **Token B Transfer**:
   - Move the agreed amount from taker to maker
   - This must succeed or the entire transaction fails

4. **Clean Up**:
   - Close the escrow account
   - Return rent to the taker (as they initiated the transaction)

This atomic sequence ensures that either:
- The entire swap completes successfully
- Nothing happens at all

There's no way for one party to get their tokens without fulfilling their side of the deal.

<ArticleSection name="Refund" id="refund" level="h2" />

The `refund` instruction lets the maker cancel an open offer:
- Close the escrow PDA and send its rent lamports back to the maker.
- Move the full Token A balance out of the vault and back to the maker, then close the vault account.

### Required Account

Knowing that this are the required accounts:

- maker: the creator of the escrow. Must be a signer and mutable
- escrow: the escrow account that we're initializing. Must be mutable
- mint_a: the token we're depositing in the escrow
- mint_b: the token we want to receive
- maker_ata_a: the associated token account owned by the maker. Must be mutable
- vault: the associated token account owned by the escrow. Must be mutable
- associated_token_program: the associated token program. Must be executable
- token_program: the token program. Must be executable
- system_program: the system program. Must be executable

We're going to let you create your own account struct since now you should be familiar with the process.

### Instruction Data

All the data that we need to perform the logic already lives in the Escrow account or on the accounts that we're deserializing. For this reason we don't need any `instruction_data` for this instruction.

### Logic

Here again, we're going to let you spread your wings and create your own logic for this! Don't be scared to go back to the previous sections to see how we implemented the make and take instruction, or reach out on Discord if you get stuck.

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

You can now test your program against our unit tests and claim your NFTs!

Start by building your program using the following command in your terminal:

```
cargo build-bpf
```

This generated a `.so` file directly in your `target/deploy` folder. 

Now click on the `take challenge` button and drop the file there!