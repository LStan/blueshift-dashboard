import { ArticleSection } from "../../../../../components/ArticleSection/ArticleSection";

<ArticleSection name="Refund" id="refund" level="h2" />

Тепер ми можемо перейти до інструкції `refund`, яка знаходиться в `refund.rs` і виконає такі дії:
- Закриє PDA ескроу та поверне його орендні лампорти назад мейкеру.
- Перемістить повний баланс Токена А з сховища назад до мейкера, а потім закриє рахунок сховища.

### Рахунки 

Рахунки, необхідні в цьому контексті:
- `maker`: користувач, який визначив умови обміну
- `escrow`: рахунок, де зберігаються всі умови цього обміну
- `mint_a`: токен, який `maker` вніс на депозит
- `vault`: токен-рахунок, пов'язаний з `escrow` та `mint_a`, куди були внесені токени
- `maker_ata_a`: токен-рахунок, пов'язаний з `maker` та `mint_a`, який отримає токени з `vault`
- `associated_token_program`: програма асоційованих токенів, яка використовується для створення асоційованих токен-рахунків
- `token_program`: токен-програма, яка використовується для CPI-переказу
- `system_program`: системна програма, яка використовується для створення `Escrow`

Цього разу ми не допомагатимемо вам створювати `Context`, тож спробуйте зробити це самостійно! Будь ласка, переконайтеся, що використовуєте правильний порядок рахунків, інакше наші тести не пройдуть.

### Логіка 

Логіка схожа на інструкцію `take`, але цього разу ми просто переміщуємо токени з `vault` до `maker_ata_a` перед закриттям тепер уже порожнього сховища. 

Цього разу ваша черга навчитися робити це самостійно, тому ми не розповідатимемо вам, яким є рішення.

Просто знайте, що після виконання цієї операції пропозиція стає недійсною, сховище зникає, а творець отримує свій Токен А та орендну плату назад у свій гаманець.

<ArticleSection name="Entrypoint" id="entrypoint" level="h2" />

Тепер, коли ми створили всі функції в різних інструкціях, ми нарешті можемо заповнити `lib.rs` усіма створеними функціями; ось так:

```rust
#[program]
pub mod blueshift_anchor_escrow {
    use super::*;

    pub fn make(ctx: Context<Make>, seed: u64, receive: u64, amount: u64) -> Result<()> {
        instructions::make::handler(ctx, seed, receive, amount)
    }

    pub fn take(ctx: Context<Take>) -> Result<()> {
        instructions::take::handler(ctx)
    }

    pub fn refund(ctx: Context<Refund>) -> Result<()> {
        instructions::refund::handler(ctx)
    }
}
```

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

Тепер ви можете перевірити свою програму за допомогою наших модульних тестів і отримати свої NFT!

Почніть з компіляції вашої програми, використовуючи таку команду в терміналі

```bash
anchor build
```

Це згенерувало файл `.so` безпосередньо у вашій папці `target/deploy`. 

Тепер натисніть на кнопку `take challenge` і перетягніть туди файл!
