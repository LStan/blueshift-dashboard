import { ArticleSection } from "../../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../../components/Codeblock/Codeblock";

<ArticleSection name="Refund" id="refund" level="h2" />

Bây giờ chúng ta có thể chuyển đến lệnh `refund`, nằm trong `refund.rs` và sẽ thực hiện các hành động sau:

- Đóng tài khoản PDA escrow và gửi rent lamports của nó trở lại cho maker.
- Chuyển toàn bộ số dư Token A ra khỏi vault và chuyển trả lại cho maker, sau đó đóng tài khoản vault.

### Các tài khoản

Các tài khoản cần thiết trong ngữ cảnh này là:

- `maker`: người dùng đã quyết định các điều khoản của việc trao đổi
- `escrow`: tài khoản nơi tất cả các điều khoản của việc trao đổi này tồn tại
- `mint_a`: token mà `maker` đã gửi
- `vault`: tài khoản token liên kết với `escrow` và `mint_a` nơi các token đã được giữ
- `maker_ata_a`: tài khoản token liên kết với `maker` và `mint_a` sẽ nhận token từ `vault`
- `associated_token_program`: chương trình associated token được sử dụng để tạo các tài khoản associated token
- `token_program`: chương trình token được sử dụng để gọi CPI việc chuyển
- `system_program`: chương trình hệ thống được sử dụng để tạo `Escrow`

Lần này chúng tôi sẽ không giúp bạn bằng cách tạo `Context`, vì vậy hãy thử tự làm! Vui lòng đảm bảo sử dụng đúng thứ tự tài khoản hoặc các bài kiểm tra của chúng tôi sẽ thất bại.

### Logic

Logic tương tự như lệnh `take` nhưng lần này chúng ta chỉ chuyển token từ `vault` đến `maker_ata_a` trước khi đóng vault hiện đã trống.

Lần này đến lượt bạn học cách tự làm, vì vậy chúng tôi sẽ không cho bạn biết giải pháp là gì.

Chỉ cần biết rằng một khi điều này thực thi, đề nghị sẽ vô hiệu, vault sẽ biến mất, và maker sẽ có Token A và rent của họ trở lại trong ví.

<ArticleSection name="Entrypoint" id="entrypoint" level="h2" />

Bây giờ chúng ta đã tạo tất cả các hàm trong các lệnh khác nhau, cuối cùng chúng ta có thể điền vào `lib.rs` với tất cả các hàm mà chúng ta đã tạo; như thế này:

<Codeblock lang="rust">
```rust
#[program]
pub mod blueshift_anchor_escrow {
    use super::*;

    pub fn make(ctx: Context<Make>, seed: u64, receive: u64, amount: u64) -> Result<()> {
        instructions::make::handler(ctx, seed, receive, amount)
    }

    pub fn take(ctx: Context<Take>) -> Result<()> {
        instructions::take::handler(ctx)
    }

    pub fn refund(ctx: Context<Refund>) -> Result<()> {
        instructions::refund::handler(ctx)
    }

}

```
</Codeblock>

<ArticleSection name="Kết luận" id="conclusion" level="h2" />

Bây giờ bạn có thể kiểm tra chương trình của mình với các unit test của chúng tôi và nhận NFT!

Bắt đầu bằng cách build chương trình của bạn bằng lệnh sau trong terminal

```bash
anchor build
```

Lệnh này sẽ tạo ra file `.so` trực tiếp trong thư mục `target/deploy`.

Bây giờ hãy click vào nút `take challenge` và thả file vào đó!