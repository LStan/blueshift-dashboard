import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# The Escrow

An escrow is a powerful financial tool that enables secure token swaps between two parties. 

Think of it as a digital safe deposit box where one user can lock up Token A, waiting for another user to deposit Token B before the swap is completed. 

This creates a trustless environment where neither party needs to worry about the other backing out of the deal.

In this challenge, we're going to implement this concept through three simple but powerful instructions:
- **Make**: The maker (first user) defines the trade terms and deposits the agreed amount of Token A into a secure vault. This is like putting your item in the safe deposit box and setting the terms of the exchange.
- **Take**: The taker (second user) accepts the offer by transferring the promised amount of Token B to the maker, and in return, receives the locked Token A. This is the moment when both parties complete their side of the deal.
- **Refund**: If the maker changes their mind or no suitable taker is found, they can cancel the offer and retrieve their Token A. This is like getting your item back from the safe deposit box if the deal falls through.

**Note**: If you're not familiar with Anchor, you should start by reading the [Instroduction to Anchor](learn.blueshift.gg/en/courses/introduction-to-anchor) to familiarize with the core concept that we're going to use in this program.

<ArticleSection name="Installation" id="installation" level="h2" />

Let's start by creating a fresh Anchor workspace:

```
anchor init blueshift_anchor_escrow
cd blueshift_anchor_escrow
```

We then continue by enabling `init-if-needed` on the `anchor-lang` crate and by adding the `anchor-spl` crate as well:

```
cargo add anchor-lang --features init-if-needed
cargo add anchor-spl
```

Since we're using `anchor-spl`, we also need to update the `Cargo.toml` file to include `anchor-spl/idl-build` in the `idl-build` feature. 

Open `Cargo.toml` and you'll see an existing `idl-build` line that looks like this:

```toml
idl-build = ["anchor-lang/idl-build"]
```

Modify it to add `anchor-spl/idl-build` as well:

```toml
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]
```

You can now open  the newly generated folder, and you're ready to start coding! 

<ArticleSection name="Template" id="template" level="h2" />

This time, since the program is quite complex, we're going to split it into small, focused modules instead of cramming everything into the `lib.rs`. 

The folder tree will look roughly like this:

```
src
├── instructions
│       ├── make.rs
│       ├── mod.rs
│       ├── refund.rs
│       └── take.rs
├── errors.rs
├── lib.rs
└── state.rs
```

Which the `lib.rs` will look roughly like this:

<Codeblock lang="rust">
```rust
use anchor_lang::prelude::*;

mod state;
mod errors;
mod instructions;
use instructions::*;

declare_id!("22222222222222222222222222222222222222222222");

#[program]
  pub mod blueshift_anchor_escrow {
    use super::*;

    #[instruction(discriminator = 0)]
    pub fn make(ctx: Context<Make>, seed: u64, receive: u64, amount: u64) -> Result<()> {
      //...
    }

    #[instruction(discriminator = 1)]
    pub fn take(ctx: Context<Take>) -> Result<()> {
      //...
    }

    #[instruction(discriminator = 2)]
    pub fn refund(ctx: Context<Refund>) -> Result<()> {
      //...
    }
}
```
</Codeblock>

As you see, we implemented custom discriminator for the instructions. So make sure to use an anchor version 0.31.0 or older.

<ArticleSection name="State" id="state" level="h2" />

We're going to move into the `state.rs` where all the data for our `Escrow` lives. To do so we're going to give it a custom discriminator and wrap the struct into the `#[account]` macro like this:

<Codeblock lang="rust">
```rust
use anchor_lang::prelude::*;

#[derive(InitSpace)]
#[account(discriminator = 1)]
  pub struct Escrow {
  pub seed: u64,
  pub maker: Pubkey,
  pub mint_a: Pubkey,
  pub mint_b: Pubkey,
  pub receive: u64,
  pub bump: u8,
}
  ```
</Codeblock>

What each field does:
- **seed**: Random number used during seed derivation so one maker can open multiple escrows with the same token pair; stored on-chain so we can always re-derive the PDA.
- **maker**: The wallet that created the escrow; needed for refunds and to receive payment.
- **mint_a** & **mint_b**: The SPL mints addresses for the "give" and "get" sides of the swap.
- **receive**: How much of token B the maker wants. (The vault's balance itself shows how much token A was deposited, so we don't store that.)
- **bump**: Cached bump byte; deriving it on the fly costs compute, so we save it once.

We could pack in more info, but extra bytes mean extra rent. Storing only the essentials keeps deposits cheap while still letting the program enforce every rule it needs.

We finish by adding the `#[derive(InitSpace)]` macro so we don't have to manually calculate the rent of this struct.

<ArticleSection name="Errors" id="errors" level="h2" />

We can now move to the `errors.rs` file where we're going to add some errors that we're going to use later like this: 

<Codeblock lang="rust">
```rust
use anchor_lang::prelude::*;

#[error_code]
pub enum EscrowError {
  #[msg("Invalid amount")]
  InvalidAmount,
  #[msg("Invalid maker")]
  InvalidMaker,
  #[msg("Invalid mint a")]
  InvalidMintA,
  #[msg("Invalid mint b")]
  InvalidMintB,
}
```
</Codeblock>

Each enum maps to a clear, human-readable message that Anchor will surface whenever a constraint or `require!()` fails.

<ArticleSection name="Make" id="make" level="h2" />

We can now move to the `make` instruction, that lives in the `make.rs` and will perform this actions:
- Initialises the Escrow record and stores all the terms.
- Creates the Vault (an ATA for `mint_a` owned by the `escrow`).
- Moves the maker's Token A into that vault with a CPI to the SPL-Token program.

### Accounts 

The accounts needed in this context are:
- `maker`: the user that decide the terms and deposit the `mint_a` into the `Escrow`
- `escrow`: the account where all the terms of this exchange lives
- `mint_a`: the token that the `maker` is depositing
- `mint_b`: the token that the `maker` wants in exchange
- `maker_ata_a`: the token account associated with the `maker` and `mint_a` used to the deposit tokens in the `vault`
- `vault`: the token account associated with the `escrow` and `mint_a` where the tokens deposits gets parked
- `associated_token_program`: the associated token program used to create the associated token accounts
- `token_program`: the token program used to CPI the transfer
- `system_program`: the system program used to create the `Escrow`

And with all the constraint it will look something like this:

<Codeblock lang="rust">
```rust
#[instruction(seed: u64)]
pub struct Make<'info> {
  #[account(mut)]
  pub maker: Signer<'info>,
  #[account(
    init,
    payer = maker,
    space = Escrow::INIT_SPACE + Escrow::DISCRIMINATOR.len(),
    seeds = [b"escrow", maker.key().as_ref(), seed.to_le_bytes().as_ref()],
    bump,
  )]
  pub escrow: Account<'info, Escrow>,

  /// Token Accounts
  #[account(
    mint::token_program = token_program
  )]
  pub mint_a: InterfaceAccount<'info, Mint>,
  #[account(
    mint::token_program = token_program
  )]
  pub mint_b: InterfaceAccount<'info, Mint>,
  #[account(
    mut,
    associated_token::mint = mint_a,
    associated_token::authority = maker,
    associated_token::token_program = token_program
  )]
  pub maker_ata_a: InterfaceAccount<'info, TokenAccount>,
  #[account(
    init,
    payer = maker,
    associated_token::mint = mint_a,
    associated_token::authority = escrow,
    associated_token::token_program = token_program
  )]
  pub vault: InterfaceAccount<'info, TokenAccount>,

  /// Programs
  pub associated_token_program: Program<'info, AssociatedToken>,
  pub token_program: Interface<'info, TokenInterface>,
  pub system_program: Program<'info, System>,
}
```
</Codeblock>

**Note**: Since we supply only one `token_program` to make sure that the CPI doesn't fail in the `take` instruction, where we perform transfer with both mint, we need to check that the two mint are owned by the same program.

### Logic 

After initializing the Accounts, we can finally handle the logic by creating smaller helper function as an implementation of the account struct.

We start by populating the `Escrow` using the `set_inner()` helper, and we then move onto depositing the tokens through the `transfer` CPI like this:

<Codeblock lang="rust">
```rust
impl<'info> Make<'info> {
  /// # Create the Escrow
  fn populate_escrow(&mut self, seed: u64, amount: u64, bump: u8) -> Result<()> {
    self.escrow.set_inner(Escrow {
      seed,
      maker: self.maker.key(),
      mint_a: self.mint_a.key(),
      mint_b: self.mint_b.key(),
      receive: amount,
      bump,
    });

    Ok(())
  }

  /// # Deposit the tokens
  fn deposit_tokens(&self, amount: u64) -> Result<()> {
    transfer_checked(
      CpiContext::new(
        self.token_program.to_account_info(),
        TransferChecked {
          from: self.maker_ata_a.to_account_info(),
          mint: self.mint_a.to_account_info(),
          to: self.vault.to_account_info(),
          authority: self.maker.to_account_info(),
      }), amount, self.mint_a.decimals
    )?;

    Ok(())
  }
}
```
</Codeblock>

We can see that Anchor helps us in multiple ways:
- `set_inner()`: guarantees every field is populated.
- `transfer_checked`: wraps the Token CPI just like the System helpers we used earlier.

And now we can move onto creating an `handler` function where we perform some checks before using the helpers, like this:

<Codeblock lang="rust">
```rust
pub fn handler(ctx: Context<Make>, seed: u64, receive: u64, amount: u64) -> Result<()> {
  // Validate the amount
  require_gte!(receive, 0, EscrowError::InvalidAmount);
  require_gte!(amount, 0, EscrowError::InvalidAmount);

  // Save the Escrow Data
  ctx.accounts.populate_escrow(seed, receive, ctx.bumps.escrow)?;

  // Deposit Tokens
  ctx.accounts.deposit_tokens(amount)?;

  Ok(())
}
  ```
</Codeblock>

Here we add two validation checks; one on the `amount` and one on the `receive` arguments to ensure we're not passing a zero value for either.

<ArticleSection name="Take" id="take" level="h2" />

We can now move to the `take` instruction, that lives in the `take.rs` and will perform this actions:
- Close the escrow record, sending its rent lamports back to the maker.
- Move Token A from the vault to the taker, then close the vault.
- Move the agreed amount of Token B from the taker to the maker.

### Accounts 

The accounts needed in this context are:
- `taker: the user that accepted the terms of the `maker` and is making the exchange
- `maker`: the user that initially set the terms
- `escrow`: the account where all the terms of this exchange lives
- `mint_a`: the token that the `maker` has deposited
- `mint_b`: the token that the `maker` wants in exchange
- `vault`: the token account associated with the `escrow` and `mint_a` that will send the tokens to the `taker`
- `taker_ata_a`: the token account associated with the `taker` and `mint_a` that will receive the tokens from the `vault`
- `taker_ata_b`: the token account associated with the `taker` and `mint_b` that will send the tokens to the `maker`
- `maker_ata_b`: the token account associated with the `maker` and `mint_b` that will receive the tokens to the `taker`
- `associated_token_program`: the associated token program used to create the associated token accounts
- `token_program`: the token program used to CPI the transfer
- `system_program`: the system program used to create the `Escrow`

And with all the constraint it will look something like this:

<Codeblock lang="rust">
  ```rust
#[derive(Accounts)]
pub struct Take<'info> {
  #[account(mut)]
  pub taker: Signer<'info>,
  #[account(mut)]
  pub maker: SystemAccount<'info>,
  #[account(
    mut,
    close = maker,
    seeds = [b"escrow", maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
    bump = escrow.bump,
    has_one = maker @ EscrowError::InvalidMaker,
    has_one = mint_a @ EscrowError::InvalidMintA,
    has_one = mint_b @ EscrowError::InvalidMintB,
  )]
  pub escrow: Box<Account<'info, Escrow>>,

  /// Token Accounts
  pub mint_a: Box<InterfaceAccount<'info, Mint>>,
  pub mint_b: Box<InterfaceAccount<'info, Mint>>,
  #[account(
    mut,
    associated_token::mint = mint_a,
    associated_token::authority = escrow,
    associated_token::token_program = token_program
  )]
  pub vault: Box<InterfaceAccount<'info, TokenAccount>>,
  #[account(
    init_if_needed,
    payer = taker,
    associated_token::mint = mint_a,
    associated_token::authority = taker,
    associated_token::token_program = token_program
  )]
  pub taker_ata_a: Box<InterfaceAccount<'info, TokenAccount>>,
  #[account(
    mut,
    associated_token::mint = mint_b,
    associated_token::authority = taker,
    associated_token::token_program = token_program
  )]
  pub taker_ata_b: Box<InterfaceAccount<'info, TokenAccount>>,
  #[account(
    init_if_needed,
    payer = taker,
    associated_token::mint = mint_b,
    associated_token::authority = maker,
    associated_token::token_program = token_program
  )]
  pub maker_ata_b: Box<InterfaceAccount<'info, TokenAccount>>,

  /// Programs
  pub associated_token_program: Program<'info, AssociatedToken>,
  pub token_program: Interface<'info, TokenInterface>,
  pub system_program: Program<'info, System>,
}
  ```
</Codeblock>

### Logic 

In the logic we then start by transfering the tokens from the `taker_ata_b` to the `maker_ata_b`; we then move onto transferring the tokens from the `vault` to the `taker_ata_a` before closing the now empty vault like this:

<Codeblock lang="rust">
```rust
impl<'info> Take<'info> {
  fn transfer_to_maker(&mut self) -> Result<()> {
    transfer_checked(
      CpiContext::new(
        self.token_program.to_account_info(),
          TransferChecked {
          from: self.taker_ata_b.to_account_info(),
          to: self.maker_ata_b.to_account_info(),
          mint: self.mint_b.to_account_info(),
          authority: self.taker.to_account_info(),
        },
      ), self.escrow.receive, self.mint_b.decimals
    )?;

    Ok(())
  }

  fn withdraw_and_close_vault(&mut self) -> Result<()> {
    // Create the signer seeds for the Vault
    let signer_seeds: [&[&[u8]]; 1] = [&[
      b"escrow",
      self.maker.to_account_info().key.as_ref(),
      &self.escrow.seed.to_le_bytes()[..],
      &[self.escrow.bump],
    ]];

    // Transfer Token A (Vault -> Taker)
    transfer_checked(
      CpiContext::new_with_signer(
        self.token_program.to_account_info(),
        TransferChecked {
          from: self.vault.to_account_info(),
          to: self.taker_ata_a.to_account_info(),
          mint: self.mint_a.to_account_info(),
          authority: self.escrow.to_account_info(),
        },
        &signer_seeds
      ), self.vault.amount, self.mint_a.decimals
    )?;

    // Close the Vault
    close_account(
      CpiContext::new_with_signer(
        self.token_program.to_account_info(),
        CloseAccount {
          account: self.vault.to_account_info(),
          authority: self.escrow.to_account_info(),
          destination: self.maker.to_account_info(),
        },
        &signer_seeds
      )
    )?;

    Ok(())
  }
}
```
</Codeblock>

We know create the `handler` function and this time luckily we don't need to perform any additional like checks so it will look like this:

<Codeblock lang="rust">
```rust
pub fn handler(ctx: Context<Take>) -> Result<()> {
  // Transfer Token B to Maker
  ctx.accounts.transfer_to_maker()?;

  // Withdraw and close the Vault
  ctx.accounts.withdraw_and_close_vault()?;

  Ok(())
}
```
</Codeblock>

<ArticleSection name="Refund" id="refund" level="h2" />

We can now move to the `refund` instruction, that lives in the `refund.rs` and will perform this actions:
- Close the escrow PDA and send its rent lamports back to the maker.
- Move the full Token A balance out of the vault and back to the maker, then close the vault account.

### Accounts 

The accounts needed in this context are:
- `maker`: the user that decided the terms of the exchange
- `escrow`: the account where all the terms of this exchange lives
- `mint_a`: the token that the `maker` has deposited
- `vault`: the token account associated with the `escrow` and `mint_a` where the tokens have been deposited
- `maker_ata_a`: the token account associated with the `maker` and `mint_a` that will receive the tokens from the `vault`
- `associated_token_program`: the associated token program used to create the associated token accounts
- `token_program`: the token program used to CPI the transfer
- `system_program`: the system program used to create the `Escrow`

This time we're not going to help you by creating the `Context`, so try doing it yourself! Please make sure to use the right order of accounts or our tests will fail.

### Logic 

The logic is similar to the `take` instruction but this time we just move the tokens from the `vault` to the `maker_ata_a` before closing the now empty vault. 

This time again is time you learn how to do it yourself, so we're not going to tell you what the solution is.

Just know that once this executes, the offer is void, the vault is gone, and the maker has their Token A and rent back in their wallet.

<ArticleSection name="Entrypoint" id="entrypoint" level="h2" />

Now that we created all the function in the different instruction, we can finally popoulate the `lib.rs` with all the function we created; like this:

<Codeblock lang="rust">
```rust
#[program]
pub mod blueshift_anchor_escrow {
    use super::*;

    pub fn make(ctx: Context<Make>, seed: u64, recieve: u64, amount: u64) -> Result<()> {
        instructions::make::handler(ctx, seed, recieve, amount)
    }

    pub fn take(ctx: Context<Take>) -> Result<()> {
        instructions::take::handler(ctx)
    }

    pub fn refund(ctx: Context<Refund>) -> Result<()> {
        instructions::refund::handler(ctx)
    }
}
```
</Codeblock>

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

You can now test your program against our unit tests and claim your NFTs!

Start by building your program using the following command in your terminal

```
anchor build
```

This generated a `.so` file directly in your `target/deploy` folder. 

Now click on the `take challenge` button and drop the file there!
