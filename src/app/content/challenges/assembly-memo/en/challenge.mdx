import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

![Assembly Memo Challenge](/graphics/challenge-banners/assembly-memo.png)

# Assembly Memo

This challenge serves as an excellent introduction to sBPF assembly programming on Solana since we'll explore the simplicity of a bite-size memo program written directly in sBPF assembly. This program demonstrates fundamental concepts of Solana's assembly programming by creating a basic memo that prints instruction data to the Solana log.

<ArticleSection name="Program Structure" id="program-structure" level="h2" />

Let's look at the complete program first, then break it down section by section:

<Codeblock lang="assembly">
```assembly
.equ NUM_ACCOUNTS, 0x00;
.equ DATA_LEN, 0x08;
.equ DATA, 0x10;
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]
  ldxdw r2, [r1+DATA_LEN]
  add64 r1, DATA
  call sol_log_
  exit
```
</Codeblock>

### Constants

The program begins by declaring three `.equ` constants that define the memory layout of our instruction data:

<Codeblock lang="assembly">
```assembly
.equ NUM_ACCOUNTS, 0x00;  ; Offset for number of accounts
.equ DATA_LEN, 0x08;      ; Offset for data length
.equ DATA, 0x10;          ; Offset for actual data
```
</Codeblock>

These constants mark the byte-offsets relative to the entry-buffer pointer in `r1`:
- `NUM_ACCOUNTS`: Position of the account count field
- `DATA_LEN`: Position of the instruction data length
- `DATA`: Position where the actual instruction data begins

> This are all known at compilation because of the way that the `input` data that is passed in the entrypoint is structured.

### Entrypoint

The entrypoint is where our program begins execution:

<Codeblock lang="assembly">
```assembly
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]   ; Load number of accounts into r0
```
</Codeblock>

This first instruction loads the number of accounts into `r0`. Since `r0` is the register the VM reads on exit, this serves two purposes:
1. It loads the account count for our use
2. It ensures the program will fail automatically if any accounts are passed (non-zero value in r0)

### Syscall

Next, we prepare the arguments for the `sol_log_` syscall:

<Codeblock lang="assembly">
```assembly
ldxdw r2, [r1+DATA_LEN]   ; Load length of memo into r2
add64  r1, DATA           ; Adjust r1 to point to memo bytes
```
</Codeblock>

These instructions set up the arguments for `sol_log_`:
- `r2` receives the length of the memo data
- `r1` is adjusted to point directly to the memo bytes

And after that, we make the system call and exit:

<Codeblock lang="assembly">
```assembly

call 16   ; Call sol_log_ (helper ID 16)
exit      ; Return using r0 value
```
</Codeblock>

The program:
1. Calls helper ID 16 (`sol_log_`) to print the memo to the validator log
2. Exits using the value in `r0`


<ArticleSection name="Conclusion" id="conclusion" level="h2" />

You can now test your program against our unit tests and claim your NFTs!

Start by building your program using the following command in your terminal:

```
coming soon
```

This will generate a `.so` file in your `target/deploy` folder. 

Now click on the `take challenge` button and drop the file there!