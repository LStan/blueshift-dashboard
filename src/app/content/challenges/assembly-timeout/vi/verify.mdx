import { ChallengeTitle } from "../../../../components/Challenges/ChallengeTitle";
import { RequirementList } from "../../../../components/Challenges/RequirementList";
import { Requirement } from "../../../../components/Challenges/Requirement";

<ChallengeTitle>sBPF Assembly Timeout</ChallengeTitle>

Bây giờ khi bạn đã bắt đầu cảm thấy thoải mái khi viết Assembly, thay vì sử dụng syscall `sol_get_clock_sysvar`, hãy cố gắng đạt được cùng một mục tiêu bằng cách chuyển tài khoản `Clock` vào làm một trong các tài khoản của instruction.

Tạo một chương trình chỉ có 1 instruction. Nó phải:
- Nhận vào một tài khoản `Clock` (kích thước 40 byte).
- Nhận vào một số lượng tối đa ở dạng 8-byte trong dữ liệu instruction.
- Sử dụng 8 byte đầu tiên của tài khoản `Clock` để lấy slot hiện tại.
- Kiểm tra xem slot hiện tại có lớn hơn số lượng tối đa được truyền trong dữ liệu instruction hay không. Nếu có, trả về mã lỗi 1.

> Để lấy đúng độ lệch dữ liệu instruction, bạn có thể sử dụng công cụ của chúng tôi tại [sbpf.xyz](https://sbpf.xyz). Nhớ thêm một tài khoản và đặt độ dài dữ liệu của nó là 40!

Hãy bắt đầu bằng cách cài đặt các gói công cụ sBPF như được mô tả trong phần [Công cụ](/vi/courses/introduction-to-assembly/tooling) của khóa học Giới thiệu về Assembly và build chương trình của bạn bằng lệnh sau trong terminal:

<Codeblock lang="terminal">
```bash
sbpf build
```
</Codeblock>

Điều này sẽ tạo ra một file `.so` trong thư mục `target/deploy` của bạn.

Bây giờ hãy nhấp vào nút `take challenge` và thả file vào đó!

<RequirementList>
  <Requirement
    title="Thử thách 1: Kiểm thử Timeout"
    description="Chương trình của bạn nên thành công khi slot được truyền vào lớn hơn slot hiện tại. "
  />

  <Requirement
    title="Thử thách 2: Kiểm thử trường hợp thất bại của Timeout"
    description="Chương trình của bạn nên thất bại khi slot được truyền vào nhỏ hơn slot hiện tại."
  />
</RequirementList>