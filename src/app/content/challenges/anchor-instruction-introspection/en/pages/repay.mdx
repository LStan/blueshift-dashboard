# Repay

The `repay` instruction is the second half of our flash loan system. It performs 2 steps:
1. Verify the borrow: verify that in the first instruction, a `borrow` instruction actually happened. After that it grabs the `amount_borrowed` from the instruction data.
2. Transfer the funds back: calculate the `fee` and transfer the `borrowed_fund` + `fee` back to the protocol

<ArticleSection name="Fund Transfer" id="fund-transfer" level="h2" />

First, we implement the actual transfer of funds with proper validation:

<Codeblock lang="rust">
```rust
let ixs = ctx.accounts.instructions.to_account_info();

let mut amount_borrowed: u64;

if let Ok(repay_ix) = load_instruction_at_checked(0, &ixs) {
    // Check the amount borrowed:
    let mut borrowed_data: [u8;8] = [0u8;8];
    borrowed_data.copy_from_slice(&repay_ix.data[8..16]);
    amount_borrowed = u64::from_le_bytes(borrowed_data)

} else {
    return Err(ProtocolError::MissingBorrowIx.into());
}
```
</Codeblock>

<Codeblock lang="rust">
```rust
// Add the fee to the amount borrowed (In our case we hardcoded it to 500 basis point)
let fee = (amount_borrowed as u128).checked_mul(500).unwrap().checked_div(10_000).ok_or(ProtocolError::Overflow)? as u64;
amount_borrowed = amount_borrowed.checked_add(fee).ok_or(ProtocolError::Overflow)?;

// Transfer the funds from the protocol to the borrower
transfer(
    CpiContext::new(ctx.accounts.token_program.to_account_info(), Transfer {
        from: ctx.accounts.borrower_ata.to_account_info(),
        to: ctx.accounts.protocol_ata.to_account_info(),
        authority: ctx.accounts.borrower.to_account_info(),
    }), 
    amount_borrowed
)?;
```
</Codeblock>