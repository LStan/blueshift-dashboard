import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Instruction Introspection with Anchor

Anchor doesn't support any specific `Instruction` sysvar helper; but all type and function used by the `solana_program` crate are inherently supported in anchor.

So to use "Instruction Introspection" in anchor we're going to need to add the `solana_program` crate to our project like this:

```
crate add solana-program
```

After this we can access all the information that we need by importing this functions:

```rust
use solana_program::sysvar::instructions::{
    self,
    load_current_index_checked, 
    load_instruction_at_checked
}; 
```

<ArticleSection name="How to use Introspection" id="how-to-use-introspection" level="h2" />

As previously said in the introduction paragraph, "Instruction Introspection" just deserialized the data of the `Instruction` sysvar account to get us all the data that we need about our instructions.

Even if the `load_instruction_at_checked` function checks that the account we're deserializing is the correct one, it's always good to add an additional check to our account struct like this:

```rust
#[account(address = instructions::ID)]
/// CHECK: InstructionsSysvar account
instructions: UncheckedAccount<'info>,
```

After this we can finally start working with "instruction introspection".

We start by checking what is the current index. We can do it by using the `load_current_index_checked` function like so:

```rust
// Check what is the current index of the instruction that is being executed (Might be in a different position than [0]).
let index = load_current_index_checked(&ctx.accounts.instructions.to_account_info())?;
```

After this, we can check an instruction at a "relative" index by using the `load_instruction_at_checked`. This time we're going to check the instruction just after the one we're using introspection in like so:

```rust
// We then Load the instruction that is right after / the one that we want to check for the correct input.
let ix = load_instruction_at_checked(index as usize + 1, &ctx.accounts.instructions.to_account_info())?;
```

Before going through the next steps we should ask ourselves what information are essential to not incur in a malicious attack.

We usually start start by checking if the program used is the one that we expect. In this example we're introspecting another instruction of this program, so we can do it like so:

```rust
require_keys_eq!(ix.program_id, ID, EscrowError::InvalidProgram);
```

We then check if the instruction is the one that we expect. To do so we compare the discriminator of the instruction with the one that we expect; in this occasion is another anchor instruction so we can do it like so:

```rust
require!(ix.data[0..8].eq(instruction::TakeEnd::DISCRIMINATOR.as_slice()), EscrowError::InvalidIx);
```

> Anchor makes it easier for us by providing the `Discriminator` trait directly on the instruction: use anchor_lang::Discriminator.

We can then do more program specific checks based on the logic of the instruction that we are checking.

In this example we start by checking that the instruction data, an amount, is correct. Instruction data is always deserialized after the discriminator, so we can do it like so:

```rust
require!(ix.data[8..16].eq(&escrow.take_amount.to_le_bytes()), EscrowError::InvalidAmount);
```

We then check the accounts that are present in the introspected instruction. This step require us to know exactly the structure of the account struct since we're going to ask for the data or the pubkey of an account that is present at a certain index like this: 

```rust
let maker_ata = get_associated_token_address(&ctx.accounts.maker.key(), &escrow.mint_b);
require_keys_eq!(ix.accounts.get(3).unwrap().pubkey, maker_ata, EscrowError::InvalidMakerATA);
```
