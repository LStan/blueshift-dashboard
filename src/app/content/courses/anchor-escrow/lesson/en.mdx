import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Chapter 2: The Escrow

![Image Test](/graphics/anchor-escrow.png)

Congrats! You just shipped your first Anchor program; from here on, things only get smoother as we rinse and repeat the patterns you've just learned, layering in new tricks along the way.

Our next stop is the Escrow; arguably the most common building block on Solana. 

Look closely at an AMM, an orderbook, or an NFT marketplace: under the hood, each relies on an escrow-style pattern. The program acts as a neutral third party, holding assets from two participants until a set of conditions is met, then releasing those assets to complete the swap.

Before we dive into the code and introduce a few new Anchor features, that we haven't seen during the Vault lesson, we need a rock-solid mental model of accounts. 

For the first time, this program will mix several account types, so it's worth taking a moment to see how they fit together.

<ArticleSection name="Account on Solana" id="account-on-solana" level="h2" />

On Solana every piece of state lives in an account; picture the [ledger](https://solana.com/docs/references/terminology#ledger) as one giant table where each row shares the same base schema:

```rust
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
    /// the program that owns this account and can mutate its lamports or data.
    pub owner: Pubkey,
    /// `true` if the account is a program; `false` if it merely belongs to one
    pub executable: bool,
    /// the epoch at which this account will next owe rent (currently deprecated and is set to `0`)
    pub rent_epoch: Epoch,
}
```

All accounts on Solana share the same base layout. What sets them apart is the program that owns them, as the program has exclusive rights to add, delete, or modify the data stored inside.

So when we talk about a Token Account, we mean an account owned by the Token Program. Unlike a plain System Account (whose data field is empty), a token-program account can be either a **Mint** or a **Token** account. We'll look at both in a moment.

Another important category of accounts are the Program Accounts: accounts owned by on-chain programs that are used to store critical protocol or user state. The `Escrow` record we are going to create in this chapter is exactly this kind of account.

<ArticleSection name="Token Program" id="token-program" level="h2" />

The Token Program, part of the Solana Program Library (SPL), is the built-in toolkit for minting and moving any asset that isn't native SOL. It has instructions to create tokens, mint new supply, transfer balances, burn, freeze, and more.

This program owns two key account types:
- **Mint Account**: stores the metadata for one specific token: supply, decimals, mint authority, freeze authority, and so on.
- **Token Account**: holds a balance of that mint for a particular owner. Only the owner can reduce the balance (transfer, burn, etc.), but anyone can send tokens to the account, increasing its balance

In our Escrow program we'll create both kinds of accounts and show how the vault PDA safely moves balances between them.

<ArticleSection name="Program Accounts" id="program-accounts" level="h2" />

We've already covered Anchor's core macros in the previous unit; now we'll put one of its most powerful macros to work. In this section we'll use `#[account]` to define a custom data structure and store it inside an account that our program owns.

### `#[account]`

In the vault example, our PDA is an empty System Program account with a deterministic address. When a PDA is owned by our program, it unlocks its second superpower: the ability to write arbitrary data to it. Anchor makes this process seamless.

First, declare the data you want to live inside the account:

```rust 
use anchor_lang::prelude::*;

#[account]
pub struct Escrow {
    pub seed: u64,
    pub maker: Pubkey,
    pub mint_a: Pubkey,
    pub mint_b: Pubkey,
    pub receive: u64,
    pub bump: u8,
}

impl Space for Escrow {
    const INIT_SPACE: usize = Self::DISCRIMINATOR.len() + 8 + 32 + 32 + 32 + 8 + 1;
}
```

Creating a struct is very easy, The only constraint that we have with Anchor is that the account's data is capped at 10,240 bytes (10 KiB). If we need more, we're going to need to use `zero_copy` and chunked writes; an advanced topic for another day.

The `Space` trait tells Anchor the exact byte size of the struct so during creation we can reference it to deposit enough lamports for rent exemption. (Type sizes are in Anchor's space reference; the discriminator is usually 8 bytes, referenced here with `Self::DISCRIMINATOR.len()`.)

Here's how we're going to initiate the account in our `Account` struct:

```rust 
#[account(
    init,
    payer = maker,
    space = Escrow::INIT_SPACE,
    seeds = ["escrow".as_bytes(), maker.key().as_ref(), seed.to_le_bytes().as_ref()],
    bump,
)]
pub escrow: Account<'info, Escrow>,
```

Here are some of the fields used in the `#[account]` macro, beyond the `seeds` and `bump` fields that we have already covered, and what they do:
- **init**: tells Anchor to create the account.
- **payer**: which signer funds the rent (here, the maker).
- **space**: how many bytes to allocate. This is where the rent calculation magic happens as well.

Once we create the account, we can access its data like this:

```rust
#[account(
    seeds = ["escrow".as_bytes(), maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
    bump = escrow.bump,
)]
pub escrow: Account<'info, Escrow>
```

This structure is very similar to the PDAs we saw in previous lessons, with the main difference being that we're telling Anchor that the account should match the `Escrow` struct and should be deserialized for use accordingly.

Lastly, since we deposited lamports as rent in the account, we should close the account and retrieve the lamports once this account is not needed anymore.

```rust
#[account(
    mut,
    close = maker,
    seeds = ["escrow".as_bytes(), maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
    bump = escrow.bump,
)]
pub escrow: Account<'info, Escrow>,
```

`close` transfers whatever lamports remain in the account back to maker, then zeros out the data.

#### Anchor-spl

Natively, the core Anchor crate only bundles CPI helpers for the System Program. If you want the same hand-holding for SPL tokens you pull in the `anchor_spl` crate.

`anchor_spl` adds:
- Helper builders for every instruction in both the SPL Token and Token-2022 programs.
- Type wrappers that make it painless to verify and deserialize Mint and Token accounts.

Let's look at how the `Mint` and `Token` accounts are structured:

```rust
#[account(
    mint::authority    = <target_account>,
    mint::decimals     = <expr>,
    mint::token_program = <target_account>
)]
pub mint: Account<'info, Mint>,

#[account(
    mut,
    associated_token::mint       = <target_account>,
    associated_token::authority  = <target_account>,
    associated_token::token_program = <target_account>
)]
pub maker_ata_a: Account<'info, TokenAccount>,

```

`Account<'info, Mint>` and `Account<'info, TokenAccount>` tell Anchor to:
- confirm the account really is a Mint or Token account;
- deserialize its data so you can read fields directly;
- enforce any extra constraints you specify (`authority`, `decimals`, `mint`, `token_program`, etc.).

These token-related accounts follow the same `init` pattern used earlier. Since Anchor knows their fixed byte size, we don’t need to specify a `space` value, only the payer funding the account.

Anchor also offers `init_if_needed` macro: it checks whether the token account already exists and, if not, creates it. That shortcut isn't safe for every account type, but it's perfectly suited to token accounts, so we'll rely on it here.

As mentioned, `anchor_spl` creates helpers for both the **Token** and **Token2022** programs, with the latter introducing Token Extensions. The main challenge is that even though these accounts achieve similar goals and have comparable structures, they can't be deserialized and checked the same way since they're owned by two different programs. 

We could create more "advanced" logic to handle these different account types, but fortunately Anchor supports this scenario through **InterfaceAccounts**:

```rust
use anchor_spl::token_interface::{Mint, TokenAccount};

#[account(
    mint::authority = <target_account>,
    mint::decimals = <expr>
    mint::token_program = <target_account>
)]
pub mint: InterfaceAccounts<'info, Mint>,
#[account(
    mut,
    associated_token::mint = <target_account>,
    associated_token::authority = <target_account>,
    associated_token::token_program = <target_account>
)]
pub maker_ata_a: InterfaceAccounts<'info, TokenAccount>,
```

The key difference here is that we're using `InterfaceAccounts` instead of `Account`. This allows our program to work with both Token and Token2022 accounts without needing to handle the differences in their deserialization logic. The interface provides a common way to interact with both types of accounts while maintaining type safety and proper validation.

This approach is particularly useful when you want your program to be compatible with both token standards, as it eliminates the need to write separate logic for each program. The interface handles all the complexity of dealing with different account structures behind the scenes.

#### Account constraints

So far we’ve leaned on built-in arguments and custom error enums to catch mistakes, but Anchor lets you bolt on extra checks right in the account macro.

Here are some examples:

```rust
#[account(
    seeds = ["escrow".as_bytes(), maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
    bump = escrow.bump,
    has_one = maker @ EscrowError::InvalidMaker,
)]
pub escrow: Account<'info, Escrow>,
```

The `has_one` constraint tells Anchor: “this field on the account struct must equal this account’s key.” If the keys differ, Anchor throws `EscrowError::InvalidMaker` before your handler runs.

```rust
#[account(
    seeds = ["escrow".as_bytes(), maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
    bump = escrow.bump,
    constraint = maker.key() == escrow.maker @ EscrowError::InvalidMaker,
)]
pub escrow: Account<'info, Escrow>,
```

When the `has_one` constraint doesn't fit, such as when the field name differs, you can write a custom constraint with any boolean expression. If the expression evaluates to false, Anchor raises the specified error.

These inline constraints keep validation next to the account definition and save you from scattering `require!()` calls throughout your instruction logic.

<ArticleSection name="The Escrow Code" id="the-escrow-code" level="h1" />

Now that we’ve covered every moving part we’ll need, let’s dive into the escrow logic itself.

An escrow lets one user lock up Token A in exchange for Token B from a second user. Our program therefore boils down to three instructions:
- **Make**: the maker defines the trade terms and deposits the agreed amount of Token A.
- **Take**: the taker accepts, transfers the promised Token B to the maker, and receives the locked Token A.
- **Refund**: the maker cancels the offer and pulls back the Token A they deposited.

Let's start by creating a fresh Anchor workspace:

```
anchor init blueshift_anchor_escrow
cd blueshift_anchor_escrow
```

Add the crates we’ll need, enabling Anchor’s `init-if-needed` helper to create token accounts if they don't already exist:

```
cargo add anchor-lang --features init-if-needed
cargo add anchor-spl
```

Next, let's look at how to structure the code in `programs/blueshift_anchor_escrow/src`.

#### Template

This time we’ll split the program into small, focused modules instead of cramming everything into the `lib.rs`. The folder tree will look roughly like this:

```
src
├── instructions
│       ├── make.rs
│       ├── mod.rs          
│       ├── refund.rs
│       └── take.rs
├── errors.rs
├── lib.rs
└── state.rs
```

And this is how the `lib.rs` will look like:

<Codeblock lang="rust">
  ```rust
    use anchor_lang::prelude::*;

    mod state;
    mod errors;
    mod instructions;
    use instructions::*;

    declare_id!("22222222222222222222222222222222222222222222");

    #[program]
    pub mod blueshift_anchor_escrow {
        use super::*;

        pub fn make(ctx: Context<Make>, seed: u64, recieve: u64, amount: u64) -> Result<()> {
            //...
        }

        pub fn take(ctx: Context<Take>) -> Result<()> {
            //...
        }

        pub fn refund(ctx: Context<Refund>) -> Result<()> {
            //...
        }
    }
  ```
</Codeblock>

Now let's start with the additional file like `state.rs` and `errors.rs` before diving into the logic:

#### State

`state.rs` is straightforward; we already know how `#[account]` works, and we have already seen this structure in the past section:

```rust 
use anchor_lang::prelude::*;

#[account]
pub struct Escrow {
    pub seed: u64,
    pub maker: Pubkey,
    pub mint_a: Pubkey,
    pub mint_b: Pubkey,
    pub receive: u64,
    pub bump: u8,
}

impl Space for Escrow {
    const INIT_SPACE: usize = Self::DISCRIMINATOR.len() + 8 + 32 + 32 + 32 + 8 + 1;
}
```

What each field does:
- **seed**: random number used during seed derivation so one maker can open multiple escrows with the same token pair; stored on-chain so we can always re-derive the PDA.
- **maker**: the wallet that created the escrow; needed for refunds and to receive payment.
- **mint_a** & **mint_b**: the SPL mints addresses for the “give” and “get” sides of the swap.
- **receive**: how much of token B the maker wants. (The vault’s balance itself shows how much token A was deposited, so we don’t store that.)
- **bump**: cached bump byte; deriving it on the fly costs compute, so we save it once.

We could pack in more info, but extra bytes mean extra rent. Storing only the essentials keeps deposits cheap while still letting the program enforce every rule it needs.

#### Errors

`errors.rs` lives on its own so you can tweak or extend codes without wading through business logic:

```rust
use anchor_lang::prelude::*;

#[error_code]
pub enum EscrowError {
    #[msg("Invalid amount")]
    InvalidAmount,
    #[msg("Invalid maker")]
    InvalidMaker,
    #[msg("Invalid mint a")]
    InvalidMintA,
    #[msg("Invalid mint b")]
    InvalidMintB,
}
```

Each enum maps to a clear, human-readable message that Anchor will surface whenever a constraint or `require!()` fails.

#### Make

The `make` instruction does three jobs:
- Initialises the Escrow record and stores all deal terms.
- Creates the Vault (an ATA for `mint_a` owned by the `escrow`).
- Moves the maker’s Token A into that vault with a CPI to the SPL-Token program.

Below are the accounts the context needs. Most of these macro arguments and types were introduced earlier, so we’ll skim:

```rust
#[instruction(seed: u64)]
pub struct Make<'info> {
    #[account(mut)]
    pub maker: Signer<'info>,
    #[account(
        init,
        payer = maker,
        space = Escrow::INIT_SPACE,
        seeds = ["escrow".as_bytes(), maker.key().as_ref(), seed.to_le_bytes().as_ref()],
        bump,
    )]
    pub escrow: Account<'info, Escrow>,

    /// Token Accounts
    #[account(
        mint::token_program = token_program
    )]
    pub mint_a: InterfaceAccount<'info, Mint>,
    #[account(
        mint::token_program = token_program
    )]
    pub mint_b: InterfaceAccount<'info, Mint>,
    #[account(
        mut,
        associated_token::mint = mint_a,
        associated_token::authority = maker,
        associated_token::token_program = token_program
    )]
    pub maker_ata_a: InterfaceAccount<'info, TokenAccount>,
    #[account(
        init,
        payer = maker,
        associated_token::mint = mint_a,
        associated_token::authority = escrow,
        associated_token::token_program = token_program
    )]
    pub vault: InterfaceAccount<'info, TokenAccount>,

    /// Programs
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```
For the logic, I like to keep the handler slim and push more advanced steps into small helpers function:

```rust
impl<'info> Make<'info> {
    fn populate_escrow(&mut self, seed: u64, amount: u64, bump: u8) -> Result<()> {
        self.escrow.set_inner(Escrow {
            seed,
            maker: self.maker.key(),
            mint_a: self.mint_a.key(),
            mint_b: self.mint_b.key(),
            receive: amount,
            bump,
        });

        Ok(())
    }

    fn deposit_tokens(&self, amount: u64) -> Result<()> {
        transfer_checked(
            CpiContext::new(
                self.token_program.to_account_info(), 
                TransferChecked {
                    from: self.maker_ata_a.to_account_info(),
                    mint: self.mint_a.to_account_info(),
                    to: self.vault.to_account_info(),
                    authority: self.maker.to_account_info(),
                },
            ),
            amount,
            self.mint_a.decimals
        )?;

        Ok(())
    }
}

pub fn handler(ctx: Context<Make>, seed: u64, receive: u64, amount: u64) -> Result<()> {
    // Validate the amount
    require!(receive > 0, EscrowError::InvalidAmount);
    require!(amount > 0, EscrowError::InvalidAmount);

    // Save the Escrow Data
    ctx.accounts.populate_escrow(seed, receive, ctx.bumps.escrow)?;

    // Deposit Tokens 
    ctx.accounts.deposit_tokens(amount)?;

    Ok(())
}
```

We can see that Anchor helps us in multiple ways:
- `set_inner()`: guarantees every field is populated.
- `transfer_checked`: wraps the Token CPI just like the System helpers we used earlier.

Additionally, we add two validation checks; one on the `amount` and one on the `receive` arguments to ensure we're not passing a zero value for either.

#### Take

The `take` instruction finalizes the swap:
- Close the escrow record, sending its rent lamports back to the maker.
- Move Token A from the vault to the taker, then close the vault.
- Move the agreed amount of Token B from the taker to the maker.

These are all the accounts needed for the `Take` context:

```rust
#[derive(Accounts)]
pub struct Take<'info> {
    #[account(mut)]
    pub taker: Signer<'info>,
    #[account(mut)]
    pub maker: SystemAccount<'info>,
    #[account(
        mut,
        close = maker,
        seeds = ["escrow".as_bytes(), maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
        bump = escrow.bump,
        has_one = maker @ EscrowError::InvalidMaker,
        has_one = mint_a @ EscrowError::InvalidMintA,
        has_one = mint_b @ EscrowError::InvalidMintB,
    )]
    pub escrow: Box<Account<'info, Escrow>>,

    /// Token Accounts
    pub mint_a: Box<InterfaceAccount<'info, Mint>>,
    pub mint_b: Box<InterfaceAccount<'info, Mint>>,
    #[account(
        mut,
        associated_token::mint = mint_a,
        associated_token::authority = escrow,
        associated_token::token_program = token_program
    )]
    pub vault: Box<InterfaceAccount<'info, TokenAccount>>,
    #[account(
        init_if_needed,
        payer = taker,
        associated_token::mint = mint_a,
        associated_token::authority = taker,
        associated_token::token_program = token_program
    )]
    pub taker_ata_a: Box<InterfaceAccount<'info, TokenAccount>>,
    #[account(
        mut,
        associated_token::mint = mint_b,
        associated_token::authority = taker,
        associated_token::token_program = token_program
    )]
    pub taker_ata_b: Box<InterfaceAccount<'info, TokenAccount>>,
    #[account(
        init_if_needed,
        payer = taker,
        associated_token::mint = mint_b,
        associated_token::authority = maker,
        associated_token::token_program = token_program
    )]
    pub maker_ata_b: Box<InterfaceAccount<'info, TokenAccount>>,

    /// Programs
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

And this is how the logic will look like: 

```rust
impl<'info> Take<'info> {
    fn transfer_to_maker(&mut self) -> Result<()> {
        transfer_checked(
            CpiContext::new(
                self.token_program.to_account_info(), 
                TransferChecked {
                    from: self.taker_ata_b.to_account_info(),
                    to: self.maker_ata_b.to_account_info(),
                    mint: self.mint_b.to_account_info(),
                    authority: self.taker.to_account_info(),
                },
            ),
            self.escrow.receive,
            self.mint_b.decimals
        )?;

        Ok(())
    }

    fn withdraw_and_close_vault(&mut self) -> Result<()> {
        // Create the signer seeds for the Vault
        let signer_seeds: [&[&[u8]]; 1] = [&[
            b"escrow",
            self.maker.to_account_info().key.as_ref(),
            &self.escrow.seed.to_le_bytes()[..],
            &[self.escrow.bump],
        ]];

        // Transfer Token A (Vault -> Taker)
        transfer_checked(
            CpiContext::new_with_signer(
                self.token_program.to_account_info(), 
                TransferChecked {
                    from: self.vault.to_account_info(),
                    to: self.taker_ata_a.to_account_info(),
                    mint: self.mint_a.to_account_info(),
                    authority: self.escrow.to_account_info(),
                },
                &signer_seeds
            ),
            self.vault.amount,
            self.mint_a.decimals
        )?;
    
        // Close the Vault
        close_account(
            CpiContext::new_with_signer(
                self.token_program.to_account_info(), 
                CloseAccount {
                    account: self.vault.to_account_info(),
                    authority: self.escrow.to_account_info(),
                    destination: self.maker.to_account_info(),
                },
                &signer_seeds
            ),
        )?;

        Ok(())
    }
}

pub fn handler(ctx: Context<Take>) -> Result<()> {
    // Transfer Token B to Maker
    ctx.accounts.transfer_to_maker()?;

    // Withdraw and close the Vault
    ctx.accounts.withdraw_and_close_vault()?;

    Ok(())
}
```

**Note**: once a token account’s balance is zero you can close it to reclaim the rent, which we do for the vault above.

#### Refund

The `refund` instruction lets the maker cancel an open offer:
- Close the escrow PDA and send its rent lamports back to the maker.
- Move the full Token A balance out of the vault and back to the maker, then close the vault account.

```rust
#[derive(Accounts)]
pub struct Refund<'info> {
    #[account(mut)]
    pub maker: Signer<'info>,
    #[account(
        mut,
        close = maker,
        seeds = ["escrow".as_bytes(), maker.key().as_ref(), escrow.seed.to_le_bytes().as_ref()],
        bump = escrow.bump,
        has_one = maker @ EscrowError::InvalidMaker,
        has_one = mint_a @ EscrowError::InvalidMintA,
    )]
    pub escrow: Account<'info, Escrow>,

    /// Token Accounts
    pub mint_a: InterfaceAccount<'info, Mint>,
    #[account(
        mut,
        associated_token::mint = mint_a,
        associated_token::authority = escrow,
        associated_token::token_program = token_program
    )]
    pub vault: InterfaceAccount<'info, TokenAccount>,
    #[account(
        init_if_needed,
        payer = maker,
        associated_token::mint = mint_a,
        associated_token::authority = maker,
        associated_token::token_program = token_program
    )]
    pub maker_ata_a: InterfaceAccount<'info, TokenAccount>,

    /// Programs
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}
```

And this is how the logic will look like: 

```rust
impl<'info> Refund<'info> {
    fn withdraw_and_close_vault(&mut self) -> Result<()> {
        // Create the signer seeds for the Vault
        let signer_seeds: [&[&[u8]]; 1] = [&[
            b"escrow",
            self.maker.to_account_info().key.as_ref(),
            &self.escrow.seed.to_le_bytes()[..],
            &[self.escrow.bump],
        ]];

        // Transfer Token A (Vault -> Maker)
        transfer_checked(
            CpiContext::new_with_signer(
                self.token_program.to_account_info(), 
                TransferChecked {
                    from: self.vault.to_account_info(),
                    to: self.maker_ata_a.to_account_info(),
                    mint: self.mint_a.to_account_info(),
                    authority: self.escrow.to_account_info(),
                },
                &signer_seeds
            ),
            self.vault.amount,
            self.mint_a.decimals
        )?;

        // Close the Vault
        close_account(
            CpiContext::new_with_signer(
                self.token_program.to_account_info(), 
                CloseAccount {
                    account: self.vault.to_account_info(),
                    authority: self.escrow.to_account_info(),
                    destination: self.maker.to_account_info(),
                },
                &signer_seeds
            ),
        )?;

        Ok(())
    }
}

pub fn handler(ctx: Context<Refund>) -> Result<()> {
    // Withdraw and close the Vault (Vault -> Maker)
    ctx.accounts.withdraw_and_close_vault()?;
    
    Ok(())
}
```

Once this executes, the offer is void, the vault is gone, and the maker has their Token A and rent back in their wallet.
