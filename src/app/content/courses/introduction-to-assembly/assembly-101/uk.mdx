import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Основи асемблера sBPF

![Вступ до асемблера](/graphics/course-banners/introduction-to-assembly.png)

Щоб зрозуміти асемблер sBPF та його роль у програмах Solana, спочатку нам потрібно зрозуміти мову асемблера та як вона з'єднує високорівневий код з машинним виконанням.

<ArticleSection name="Мова асемблера" id="the-assembly-language" level="h2" />

Асемблер — це зрозуміла для людини форма машинного коду: фактичні інструкції, які виконують процесори. Він служить мостом між високорівневими мовами програмування та двійковим кодом, який розуміють комп'ютери.

Коли ви пишете код на Rust, наприклад:

```rust
let result = a + b;
```

Компілятор перекладає це через кілька етапів:
1. Вихідний код Rust → аналізується та розбирається
2. Проміжне представлення → оптимізується
3. Код асемблера → зрозумілі для людини інструкції
4. Машинний код → двійковий код, який виконує процесор

Асемблер займає етап 3: остання зрозуміла для людини форма перед перетворенням на двійковий код. Кожна інструкція асемблера відповідає рівно одній операції процесора: додавання чисел, завантаження пам'яті або перехід до різних розділів коду.

<ArticleSection name="Віртуальна машина sBPF" id="the-sbpf-virtual-machine" level="h2" />

Solana sBPF — це власний варіант Solana розширеного набору інструкцій Berkeley Packet Filter (eBPF) та віртуальної машини, яка виконує кожну програму в блокчейні. Вона створює спеціалізоване середовище виконання: 64-бітну регістрову машину, яка знаходиться між вашою програмою та нативним CPU валідатора.

Уявіть sBPF як спеціально створений комп'ютер, розроблений для виконання в блокчейні: достатньо швидкий для транзакцій з високою пропускною здатністю, але достатньо обмежений, щоб гарантувати безпеку та детермінізм на тисячах валідаторів.

На відміну від нативного асемблера, який працює безпосередньо на вашому CPU, код sBPF виконується в контрольованому середовищі віртуальної машини. Ця віртуальна машина гарантує безпеку, перевіряючи кожну інструкцію перед виконанням, запобігаючи збоям, нескінченним циклам та несанкціонованому доступу до пам'яті.

Незважаючи на ці обмеження безпеки, sBPF підтримує високу продуктивність завдяки компіляції `just-in-time`, що забезпечує швидкість виконання, близьку до нативної.

Віртуальна машина також забезпечує детерміноване виконання: ідентичні програми з ідентичними вхідними даними дають ідентичні результати на всіх валідаторах по всьому світу. Ця узгодженість є вирішальною для консенсусу блокчейну.

Крім того, sBPF включає системні виклики для доступу до облікових записів, міжпрограмних викликів та взаємодії з середовищем виконання.

### Чому важливо розуміти асемблер sBPF

Хоча компілятор Rust ефективно перетворює високорівневий код на інструкції sBPF, розуміння асемблера надає кілька переваг:
- **Розуміння обчислювальних витрат**: Кожна інструкція sBPF споживає обчислювальні одиниці (CU). Один рядок Rust може компілюватися в сотні інструкцій — асемблер показує, чому певні операції є дорогими.
- **Менші розміри програм**: Програми, написані безпосередньо на асемблері sBPF, значно менші за скомпільовані еквіваленти Rust, що зменшує витрати на розгортання та покращує час завантаження.
- **Можливості оптимізації**: Компілятор Rust генерує безпечний, правильний код, але не завжди найефективніший. Асемблер виявляє надлишкові перевірки безпеки та неоптимальні послідовності інструкцій.
- **Налагодження та аналіз**: Коли програми поводяться непередбачувано, асемблер надає точну інформацію. Ви можете простежити, які саме інструкції виконувалися, та визначити точки відмови.

### Архітектура

sBPF використовує архітектуру завантаження-зберігання з 10 регістрами загального призначення, одним вказівником стеку лише для читання та без складних режимів адресації.

Ця простота є навмисною: менша кількість варіантів інструкцій забезпечує швидшу перевірку, швидшу JIT-компіляцію та більш передбачувану продуктивність.

Щоразу, коли програма eBPF завантажується в ядро, її байт-код перетворюється JIT-компілятором на нативні машинні інструкції, специфічні для архітектури процесора хоста, а потім виконується віртуальною машиною.

### Виконання

Програми sBPF виконуються за допомогою простого процесу. Лічильник програми (`PC`) відстежує, яку інструкцію виконувати далі, як закладка у вашому списку інструкцій.

Цикл виконання складається з таких кроків:
1. **Вибірка**: Зчитування інструкції за лічильником програми
2. **Декодування**: Інтерпретація формату інструкції та операндів
3. **Виконання**: Здійснення операції (зміна регістрів, доступ до пам'яті або зміна потоку керування)
4. **Просування**: Переміщення лічильника програми до наступної інструкції (або перехід для розгалужень)
5. **Повторення**: Продовження до завершення програми

Кожна інструкція виконує рівно одну операцію: арифметичну, доступ до пам'яті, порівняння або виклик функції. Така конструкція з однією інструкцією на операцію робить програми sBPF передбачуваними та придатними для аналізу.

<ArticleSection name="Конвеєр JIT-компілятора" id="the-jit-compiler-pipeline" level="h2" />

Програми sBPF досягають високої продуктивності завдяки компіляції Just-In-Time (JIT).

Коли ви розгортаєте програму в Solana, середовище виконання здійснює дві операції:
- **Перевірка**: Забезпечує безпеку програми, перевіряючи наявність нескінченних циклів, недійсного доступу до пам'яті та потенційних збоїв. Верифікатор аналізує кожен можливий шлях виконання, щоб гарантувати безпечну роботу.
- **Компіляція**: Перетворює інструкції sBPF у нативний машинний код, який виконується безпосередньо на CPU валідатора. Прості операції, як-от `add64 r1, r2` перетворюються на одиночні нативні інструкції додавання, тоді як складні операції отримують додаткові перевірки безпеки, але все одно компілюються в ефективний нативний код.

Цей підхід обмінює час розгортання на швидкість виконання. Програми перевіряються та компілюються один раз під час розгортання, але виконуються тисячі разів, що робить це відмінним компромісом для продуктивності блокчейну.

Процес JIT-верифікації проходить через кожен можливий шлях програми, перевіряючи, що доступ до пам'яті залишається в межах, переходи спрямовані на дійсні адреси, а виконання завершується в межах обчислювальних лімітів.

Процес JIT-компіляції перетворює кожну інструкцію sBPF на еквівалентні нативні інструкції CPU. Оскільки більшість виконання відбувається в нативному коді, накладні витрати віртуальної машини мінімальні.

> Розуміння того, що sBPF компілюється у нативний код, пояснює, чому арифметичні операції швидкі, тоді як системні виклики, що переходять у середовище виконання, мають додаткові витрати. Ці знання допомагають приймати рішення щодо оптимізації.