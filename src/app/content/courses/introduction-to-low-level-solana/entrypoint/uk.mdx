import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Точка входу

`entrypoint!()` є єдиним символом, який повинна експортувати кожна програма Solana. Це точка передачі, де середовище виконання Solana переходить від завантажувача до вашого коду.

Перед переходом завантажувач упаковує все, що потрібно для інструкції, в один плоский запис у стилі C, який зберігається на вхідній сторінці віртуальної машини BPF. Потім макрос розпаковує цей запис і передає вашому Rust три безпечні зрізи та посилання:
- **program_id**: публічний ключ програми, яка зараз виконується.
- **accounts**: вказівник на суцільний масив записів AccountInfo, плюс довжина.
- **instruction_data**: зріз вказівник-плюс-довжина необроблених байтів, наданих транзакцією.

Макрос буде:
- Перетворювати ці необроблені вказівники на безпечні зрізи Rust.
- Перехоплювати паніки, щоб вони ставали чистими кодами `ProgramError::Custom` замість аварійного завершення віртуальної машини.
- Передавати все до визначеної користувачем функції (часто називається `process_instruction`), яка повертає `ProgramResult`.

Ось опис єдиного плоского запису, який завантажувач Solana розміщує на вхідній сторінці віртуальної машини BPF перед переходом до вашої точки входу.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`: кількість надісланих облікових записів.
- `account_info`: необроблені записи облікових записів в інструкції, один за одним.
- `instruction_len`: скільки байтів даних інструкції йде далі.
- `instruction_data`: сама інструкція
- `program_id`: 32-байтовий `Pubkey` програми, що виконується.

Кожен елемент масиву `account_info` потім має таку ж упаковану структуру:

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`: переконайтеся, що не "десеріалізуєте повторно" дані, якщо той самий обліковий запис з'являється в списку більше одного разу, пропускаючи його. `0xFF` означає "унікальний"; будь-яке інше значення - це індекс, який він копіює.
- `is_signer` / `is_writable` / `executable`: однобайтові прапорці, які середовище виконання використовує, щоб ваша програма могла контролювати логіку та CPI без додаткових системних викликів.
- `alignment`: Заповнювач чотирибайтового слота, який зберігає вирівнювання всієї структури по 8 байтів. Pinocchio перепризначає його для відстеження початкової довжини даних під час перерозподілу пам'яті.
- `key` / `owner` / `lamports`: Мінімально необхідні дані, які повинен мати кожен обліковий запис.
- `data_len` + `data`: Дані змінної довжини, які може мати обліковий запис.
- `padding`: Завантажувач попередньо виділяє 10_240 байтів, максимальний розмір облікового запису, щоб дані облікового запису могли змінюватися та зростати на місці без переміщення пам'яті.
- `align_padding`: Додаткове заповнення, якщо потрібно, щоб наступний `AccountRaw` все ще починався на межі 8 байтів (важливо для деяких хостів eBPF).
- `rent_epoch`: Епоха, коли обліковий запис повинен наступного разу сплатити ренту; зберігається для сумісності, навіть якщо збір ренти призупинено.
