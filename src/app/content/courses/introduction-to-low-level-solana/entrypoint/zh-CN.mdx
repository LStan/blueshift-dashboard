import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 入口点

`entrypoint!()` 是每个 Solana 程序必须公开的唯一符号。它是 Solana 运行时从加载器跳转到您的代码的交接点。

在跳转之前，加载器会将指令所需的所有内容打包成一个扁平的 C 风格记录，并存储在 BPF VM 的输入页面上。然后宏会解包该记录，并将其以三种安全的切片和引用形式传递给您的 Rust：
- **program_id**：当前正在执行的程序的 pubkey。
- **accounts**：指向 AccountInfo 记录连续数组的指针，以及一个长度。
- **instruction_data**：由交易提供的原始字节的指针加长度切片。

该宏将：
- 将这些原始指针转换为安全的 Rust 切片。
- 捕获 panic，使其成为干净的 `ProgramError::Custom` 代码，而不是导致 VM 崩溃。
- 将所有内容转发到用户定义的函数（通常称为 `process_instruction`），该函数返回一个 `ProgramResult`。

以下是 Solana 加载器在跳转到您的入口点之前放置在 BPF VM 输入页面上的单一扁平记录的描述。

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`：传入的账户数量。
- `account_info`：指令中的原始账户记录，一个接一个。
- `instruction_len`：后续指令数据的字节数。
- `instruction_data`：指令本身。
- `program_id`：程序运行时的 32 字节 `Pubkey`。

`account_info` 数组的每个元素都遵循相同的打包布局：

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`：如果同一账户在列表中出现多次，通过跳过它来确保不重新反序列化数据。`0xFF` 表示“唯一”；任何其他值是它复制的索引。
- `is_signer` / `is_writable` / `executable`：运行时使用的单字节标志，使您的程序可以在不额外调用系统调用的情况下控制逻辑和 CPI。
- `alignment`：一个占位符四字节 slot，用于在重新分配期间跟踪原始数据长度，同时保持整个结构的 8 字节对齐。Pinocchio 将其重新用于此目的。
- `key` / `owner` / `lamports`：每个账户应具有的最低可行数据。
- `data_len` + `data`：账户可能具有的可变长度数据。
- `padding`：加载器预分配了 10,240 字节，这是账户的最大大小，因此账户数据可以在不移动内存的情况下更改和增长。
- `align_padding`：如果需要，额外的填充，以便下一个 `AccountRaw` 仍然从 8 字节边界开始（对于某些 eBPF 主机很重要）。
- `rent_epoch`：账户下次必须支付租金的 epoch；为了兼容性保留，即使租金收取已暂停。
