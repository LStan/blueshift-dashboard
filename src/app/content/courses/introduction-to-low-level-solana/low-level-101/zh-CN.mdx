import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 低级编程 101

![图片测试](/graphics/banners/research-crateless-program.png)

如果您曾经编写过一个 Solana 程序，那么您一定知道，像 Entrypoint、CPI 和账户管理等程序的基本需求通常由 solana_program 和 pinocchio 这样的 crate 处理，这些 crate 被像 anchor、steel 等框架在底层使用。

但要真正理解和优化 Solana 堆栈，我们需要深入这些抽象背后，看看底层发生了什么。在本课程中，我们将从头开始创建一个完全手工编写、零依赖的 Solana 程序。

在我们研究不同的手工编写组件之前，我们需要了解构成 Solana 程序运行的基本构建块。

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Solana 程序会被编译为 eBPF（扩展伯克利数据包过滤器）字节码，而不是本地机器代码。这一架构选择解释了许多 Solana 的特点：
- **计算单元限制**：eBPF 的安全模型通过指令计数来防止无限循环
- **无堆分配**：eBPF 程序运行在没有 malloc/free 的沙盒环境中
- **有限的栈空间**：只有 4KB 的栈空间，迫使开发者谨慎管理内存
- **确定性执行**：相同的输入在所有验证者中始终产生相同的输出

这也解释了为什么某些 Rust 特性在 Solana 程序中无法使用；运行时实际上无法执行它们。

<ArticleSection name="#[repr(C)] & extern `C`" id="repr-c-and-extern-c" level="h2" />

当您查看任何低级 Solana 示例时，会发现两个模式无处不在：

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

告诉 Rust 编译器使用 C ABI（应用程序二进制接口）来暴露一个函数，这种调用约定定义了哪些 eBPF 寄存器携带参数、栈是如何布局的以及哪个寄存器返回值。

选择 C ABI 是因为它是 LLVM 的 eBPF 后端支持的所有语言（如 Rust、C、Zig，甚至是手写汇编）中最低的通用标准。Solana 运行时需要通过原始名称调用程序的入口点，并通过特定的寄存器传递参数；C ABI 保证了无论使用哪种语言编译字节码，这种方式都能正常工作。

**`#[repr(C)]`**

强制 Rust 按照 C 编译器的方式排列结构体字段，锁定字段顺序和填充，以确保字节布局永远不会改变：

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

这很重要，因为账户数据在程序调用之间是持久化的。如果 Rust 在编译之间重新排列了字段顺序，程序将无法读取之前写入的数据。

<ArticleSection name="内存布局管理" id="memory-layout-management" level="h2" />

在高级框架中，内存对齐是自动完成的。在低级别，每个字节都很重要：

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

内存管理的规则是每个字段必须从一个能被其自身大小整除的偏移量开始：
- `u8`：任何偏移量（能被 1 整除）
- `u16`：偏移量必须能被 2 整除（0, 2, 4...）
- `u32`：偏移量必须能被 4 整除（0, 4, 8...）
- `u64`：偏移量必须能被 8 整除（0, 8, 16...）

这非常重要，因为错误的内存管理可能导致内存未对齐访问，从而使程序不可预测地失败。

当手动管理账户数据序列化时，理解填充和对齐对于跨程序兼容性至关重要。

#### 系统调用

**系统调用**（system call 或 syscall）是非特权代码向其主机请求特权服务的入口。当进行系统调用时，CPU 会从用户模式切换到受信任的特权模式；运行时随后执行请求的操作，并返回一个状态码。这种间接方式防止了沙盒代码直接接触主机内存或 I/O，从而保证了安全性和确定性。

在 Solana 上，BPF 字节码无法自行进行哈希、日志记录或执行跨程序调用（CPI）。相反，它会调用命名的系统调用，例如 `sol_log`、`sol_sha256`、`sol_invoke_signed`。

每个系统调用号只是加载器调度表中的一个索引。加载器执行请求的操作并返回一个 `u64` 状态字（成功为零，失败为非零）。

例如，`sol_invoke_signed` 会打包一个指令、其账户列表以及任何 PDA 签名者的种子，将它们交给加载器，加载器在适当的权限下执行 CPI，如下所示：

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="The Vault Code" id="the-vault-code" level="h2" />

现在我们已经拆解了一个“无 crate” Solana 程序的每个构建块，我们可以概述保险库本身。请记住，保险库只执行两件事：
- **存入** lamports 到从所有者公钥派生的 PDA 中。
- **提取**这些相同的 lamports；仅限所有者提取。

因此，每个指令将携带三个账户：
- **所有者**（签名者，可写）：存入或提取资金的用户。
- **保险库**（可写）：包含所有 lamports 的 PDA。
- **系统程序**：执行 lamport 转移所需的账户。

在开始之前，我们需要创建一个新项目，为此，请在终端中运行以下命令：

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

在 `Cargo.toml` 中添加：

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### 模板

所有内容都将存放在 `lib.rs` 中。简单来说，该文件将包含系统调用填充（小型的 #[repr(C)] 结构体，用于镜像我们需要的原始系统调用布局）和作为常量的数据偏移量（以便更轻松地处理原始数据）。

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### 账户检查

在我们运行 `deposit` 或 `withdraw` 之前，入口点必须确保交易提供了完全正确的账户，并且每个账户都具有预期的标志。

由于我们在处理原始指针级别的操作，每个检查都通过简单的指针运算和直接加载完成。

输入记录的前八个字节包含 account_len。对于这个 vault，我们期望有三个账户：所有者、vault PDA 和 System Program：

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

我们继续检查每个账户，之前定义的布局偏移量让我们可以在不反序列化整个结构的情况下验证每个标志的合理性。

对于第一个账户（签名者），我们执行以下检查：
- 必须是唯一的（is_duplicate == 0xff）
- 可写（我们将更改其 lamports）
- 签名者
- 不可执行
- 必须没有数据

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我们还会存储所有者的公钥，以便稍后进行 PDA 检查：

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

对于第二个账户（vault），我们执行以下检查：
- 可写（我们将更改其 lamports）
- 由 System Program 拥有
- 数据长度必须为零（我们不在这里存储状态）

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我们还会获取 vault 的公钥，以便稍后进行 PDA 检查：

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

对于最后一个账户（System Program），我们执行以下检查：
- 必须是可执行的
- 其密钥必须等于 SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### 指令检查

在账户验证之后，我们终于可以解析指令负载了。我们采用与本地程序相同的方法，使用第一个字节作为区分符：

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

从这里开始，我们分支到存款或取款处理程序，确信每个账户和标志都完全符合 vault 的预期。

#### 存款逻辑

我们将从存款指令的更详细的演练开始。所有检查都在前面完成；一旦通过，我们会构建一个 System Program 转账并调用它。

此指令的数据结构如下：
- 字节 0 是判别器（`0x00` 表示存款）。
- 字节 1 是您将用于 PDA 检查的 bump 值。
- 字节 2-9 以小端序存储 lamport 数量，如果数量为 0，将被检查并拒绝。

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

之后，我们使用 `sol_sha256` 系统调用对所有者密钥进行哈希处理，结合 bump 值、程序 ID 和唯一字符串 "ProgramDerivedAddress"。

我们将结果与账户检查期间存储的 vault 密钥进行比较。如果它们不同，则返回 `InvalidSeeds`。

如果它们不同，则返回 `InvalidSeeds`。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

最后，我们可以构建 System Program 转账。

System Program 使用一个四字节的判别器（对于转账，该值为 2），并需要额外的 8 字节来表示我们希望从 `from_account` 转账到 `to_account` 的金额。

然后我们需要构建一个包含两个 SolAccountMeta 值的小数组：from = owner（签名者，可写），to = vault（可写）。我们将其与 `instruction_data` 结合，创建一个 `SolInstruction` 结构体：

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

但在调用 `sol_invoke_signed_c` 系统调用之前，我们需要构建两个 `SolAccountInfo` 结构体，一个用于所有者，一个用于 vault，这些结构体提供指向其 lamport 余额和数据切片的指针，正好位于加载器在内存中留下的位置。

之后，我们可以通过传递指令指针、指向两个元素的 `SolAccountInfo` 数组的指针以及账户数量（2）来调用系统调用。由于外部交易已经由所有者签名，这里不需要 PDA seeds，因此 `signers_seeds_addr` 参数为 NULL。

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### 提现逻辑

提现指令与存款类似，但有一些关键区别。指令数据更为简单：
- 字节 0 是区分符（`0x01` 表示提现）。
- 字节 1 是您将用于 PDA 检查的 bump 值。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

我们执行与存款相同的 PDA 检查，使用所有者的公钥、bump 值、程序 ID 和唯一字符串 "ProgramDerivedAddress"：

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

提现的关键区别在于我们需要使用 PDA 本身签署交易。为此，我们需要提供用于派生 PDA 的种子。我们创建一个包含两个元素的 `SolSignerSeedsC` 数组：
- 所有者的公钥（32 字节）
- bump 值（1 字节）

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

然后我们构建 System Program 转账指令，但这次是从金库转到所有者。指令数据与存款相同：
- 四字节区分符（值为 2 表示转账）
- 八字节金额（从金库的 lamports 获取）

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

账户元数据与存款相比是反向的：
- 第一个账户是金库（可写，签名者）
- 第二个账户是所有者（可写）

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

最后，我们使用指令、账户信息和之前创建的签名种子调用 `sol_invoke_signed_c`：

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="总结" id="closing-remarks" level="h2" />

虽然这种编写 Solana 程序的低级方法看起来极端，但它具有重要的教育意义。我们并不建议您以这种方式编写程序；事实上，我们强烈建议使用已建立的框架和库来简化这些复杂性。然而，理解底层机制是非常宝贵的。

在 Solana 开发中，我们使用的每一个抽象，无论是 `solana_program`、`anchor`，还是其他任何框架，都是建立在这些基本构建块之上的。通过剖析这些层次并研究其底层机制，我们可以更深入地理解：

1. Solana 运行时如何与我们的程序交互
2. 为什么在高级框架中做出某些设计决策
3. 潜在的优化可能存在于何处
4. 如何在问题发生时更好地进行调试

这些知识不仅仅是理论上的，它们是实用的。当你理解了基础，你可以：
- 通过对数据结构和内存使用的明智决策编写更高效的程序
- 在问题出现时更好地诊断和修复
- 通过改进我们共同使用的工具为生态系统做出贡献
- 在使用某些抽象和更接近底层操作之间做出明智的选择

请记住，这项练习的目标不是教你如何在没有 crates 的情况下编写程序，而是帮助你理解这些 crates 在底层的工作原理。这种理解是编写更好、更高效的 Solana 程序的第一步，无论你选择使用哪些工具。
