import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Основи низькорівневого програмування

![Image Test](/graphics/banners/research-crateless-program.png)

Якщо ви писали програму для Solana, ви напевно знаєте, що всі базові потреби програми, такі як точка входу, CPI та управління обліковими записами, зазвичай обробляються кратами, як-от solana_program та pinocchio, які використовуються під капотом фреймворками на кшталт anchor, steel, ...

Але щоб по-справжньому зрозуміти та оптимізувати стек Solana, нам потрібно зазирнути за всі ці абстракції та побачити, що відбувається під капотом. У цьому курсі ми створимо повністю власноруч написану програму Solana з нуля, без жодних залежностей.

Перш ніж розглянути різні компоненти, написані вручну, нам потрібно зрозуміти фундаментальні будівельні блоки, які забезпечують роботу програм Solana.

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Програми Solana компілюються у байткод eBPF (extended Berkeley Packet Filter), а не у нативний машинний код. Цей архітектурний вибір пояснює багато особливостей Solana:
- **Обмеження обчислювальних одиниць**: модель безпеки eBPF запобігає нескінченним циклам, підраховуючи інструкції
- **Відсутність виділення пам'яті в купі**: програми eBPF працюють у ізольованому середовищі без malloc/free
- **Обмежений стек**: лише 4 КБ стекового простору змушує ретельно керувати пам'яттю
- **Детерміноване виконання**: однакові вхідні дані завжди дають однакові вихідні дані на всіх валідаторах

Це пояснює, чому певні функції Rust просто не працюють у програмах Solana; середовище виконання буквально не може їх виконати.

<ArticleSection name="#[repr(C)] і extern `C`" id="repr-c-and-extern-c" level="h2" />

Коли ви дивитеся на будь-який низькорівневий приклад Solana, скрізь з'являються два патерни:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

Вказує компілятору Rust експортувати функцію, використовуючи ABI (Application Binary Interface) мови C, угоду про виклики, яка визначає, які регістри eBPF містять аргументи, як організований стек і який регістр повертає значення.

ABI мови C обрано, оскільки це найменший спільний знаменник для всіх мов, які підтримує бекенд eBPF від LLVM: Rust, C, Zig чи навіть асемблер, написаний вручну. Середовище виконання Solana повинно викликати точку входу вашої програми за її назвою та передавати параметри через певні регістри; ABI мови C гарантує, що це працюватиме незалежно від того, яка мова скомпілювала ваш байткод.

**`#[repr(C)]`** 

Змушує Rust розташовувати поля структури точно так, як це зробив би компілятор C, фіксуючи порядок полів і вирівнювання, щоб байтове розташування ніколи не змінювалося:

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

Це важливо, оскільки дані облікового запису зберігаються між викликами програми. Якщо Rust змінить порядок полів між компіляціями, ваша програма не зможе прочитати дані, які вона записала раніше.

<ArticleSection name="Керування розташуванням пам'яті" id="memory-layout-management" level="h2" />

У високорівневих фреймворках вирівнювання пам'яті відбувається автоматично. На низькому рівні кожен байт має значення:

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

Правило керування пам'яттю полягає в тому, що кожне поле повинно починатися зі зміщення, яке ділиться на його власний розмір:
- `u8`: Будь-яке зміщення (ділиться на 1)
- `u16`: Зміщення має ділитися на 2 (0, 2, 4...)
- `u32`: Зміщення має ділитися на 4 (0, 4, 8...)
- `u64`: Зміщення має ділитися на 8 (0, 8, 16...)

Це дуже важливо, оскільки неправильне керування пам'яттю може призвести до невирівняного доступу до пам'яті, що може спричинити непередбачувані збої вашої програми.

Коли ви вручну керуєте серіалізацією даних облікового запису, розуміння вирівнювання та заповнення стає вирішальним для міжпрограмної сумісності.

#### Системні виклики

**Системний виклик**, або syscall, — це двері, через які непривілейований код запитує привілейовану послугу від свого хоста. Коли здійснюється системний виклик, CPU перемикається з режиму користувача в довірений, привілейований режим; потім середовище виконання виконує запитану дію, і керування повертається зі статусним кодом. Це опосередкування не дозволяє ізольованому коду безпосередньо звертатися до пам'яті хоста або вводу-виводу, зберігаючи безпеку та детермінізм.

На Solana байткод BPF не може самостійно хешувати, логувати або виконувати міжпрограмний виклик (CPI). Натомість він викликає іменовані системні виклики, такі як `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Кожен номер системного виклику — це просто індекс у таблиці диспетчеризації завантажувача. Завантажувач виконує запитану операцію і повертає статусне слово `u64` (нуль для успіху, ненульове значення для помилки).

Наприклад, `sol_invoke_signed` упаковує інструкцію, її список акаунтів та будь-які насіння підписувача PDA, передає їх завантажувачу, і завантажувач виконує CPI з відповідними правами таким чином:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Код сховища" id="the-vault-code" level="h2" />

Тепер, коли ми розібрали кожен будівельний блок програми Solana "без крейтів", ми можемо окреслити саме сховище. Пам'ятайте, сховище робить рівно дві речі:
- **Депозит** лампортів у PDA, отриманий з публічного ключа власника.
- **Вивід** цих самих лампортів пізніше; тільки власником.

Кожна інструкція, таким чином, міститиме три акаунти:
- **Власник** (підписувач, доступний для запису): користувач, який вносить або виводить кошти.
- **Сховище** (доступне для запису): PDA, де зберігаються всі лампорти.
- **Системна програма**: акаунт, необхідний для здійснення переказу лампортів.

Перед початком нам потрібно створити новий проєкт, для цього виконайте цю команду в терміналі:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

У `Cargo.toml` додайте:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Шаблон 

Все буде розміщено в `lib.rs`. Загалом, файл міститиме прошарки системних викликів (маленькі структури #[repr(C)], які відображають макети сирих системних викликів, які нам знадобляться) та константи зміщення даних (щоб полегшити роботу з сирими даними).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Перевірки акаунтів

Перш ніж ми зможемо запустити `deposit` або `withdraw`, точка входу має переконатися, що транзакція надала нам саме ті акаунти, які потрібні, і що кожен з них має очікувані прапорці.

Оскільки ми працюємо на рівні сирих вказівників, кожна перевірка виконується за допомогою простої арифметики вказівників і прямого завантаження.

Перші вісім байтів вхідного запису містять account_len. Для цього сховища ми очікуємо три облікові записи: власник, PDA сховища та System Program:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Ми продовжуємо перевіркою кожного облікового запису, зміщення макета, які ми визначили раніше, дозволяють нам перевірити кожен прапорець без десеріалізації повної структури.

Для першого облікового запису, підписанта, ми виконуємо такі перевірки: 
- Має бути унікальним (is_duplicate == 0xff)
- Доступний для запису (ми змінимо його ламports)
- Підписант
- Не виконуваний
- Не повинен мати даних 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Ми також зберігаємо відкритий ключ власника для подальшої перевірки PDA:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Для другого облікового запису, сховища, ми виконуємо такі перевірки:
- Доступний для запису (ми змінимо його ламports)
- Належить System Program
- Довжина даних має бути нульовою (ми не зберігаємо стан тут)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Ми також отримуємо відкритий ключ сховища для подальшої перевірки PDA:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Для останнього облікового запису, системної програми, ми виконуємо такі перевірки: 
- Має бути виконуваним
- Його ключ має дорівнювати SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Перевірки інструкцій

Після валідації облікових записів ми нарешті можемо розібрати корисне навантаження інструкції. І ми використовуємо той самий підхід, що й нативна програма, використовуючи перший байт як дискримінатор:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

Звідси ми переходимо або до обробника депозиту, або до обробника зняття, впевнені, що кожен обліковий запис і прапорець точно відповідає очікуванням сховища.

#### Логіка депозиту

Ми почнемо з детального огляду інструкції депозиту. Усі перевірки розташовані на початку; після їх проходження ми створюємо переказ System-Program і викликаємо його.

Дані інструкції цієї інструкції виглядають так:
- Байт 0 - це дискримінатор (`0x00` для депозиту).
- Байт 1 - це bump, який ви повторно використовуватимете для перевірки PDA.
- Байти 2-9 містять кількість лампортів у форматі little-endian, яка буде перевірена і відхилена, якщо дорівнює 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Після цього ми хешуємо ключ власника за допомогою системного виклику `sol_sha256`, з bump, ідентифікатором програми та унікальним рядком "ProgramDerivedAddress".

Ми порівнюємо результат з ключем сховища, який ми зберегли під час перевірки облікового запису. Якщо вони відрізняються, повертається `InvalidSeeds`.

Якщо вони відрізняються, повертається `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Нарешті ми можемо створити переказ через System-Program.

System Program використовує чотирибайтовий дискримінатор (для переказу це значення 2) і потребує додаткових 8 байтів, які представляють суму, яку ми хочемо перевести з `from_account` до `to_account`

Потім нам потрібно створити невеликий масив із двох значень SolAccountMeta: from = власник (підписант, доступний для запису), to = сховище (доступне для запису). Ми об'єднуємо це з `instruction_data` для створення структури `SolInstruction`:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Але перед викликом системного виклику `sol_invoke_signed_c` нам потрібно створити дві структури `SolAccountInfo`, одну для власника та одну для
сховища, які надають вказівники на їхні баланси лампортів і зрізи даних саме там, де завантажувач залишив їх у пам'яті.

Після цього ми можемо викликати системний виклик, передавши вказівник інструкції, вказівник на ваш двоелементний масив `SolAccountInfo` і кількість облікових записів (2). Оскільки зовнішня транзакція вже підписана власником, насіння PDA тут не потрібне, тому аргумент `signers_seeds_addr` є NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Логіка виведення коштів

Інструкція виведення коштів схожа на депозит, але з кількома ключовими відмінностями. Дані інструкції простіші:
- Байт 0 — дискримінатор (`0x01` для виведення).
- Байт 1 — це bump, який ви повторно використовуватимете для перевірки PDA.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Ми виконуємо ту саму перевірку PDA, що й при депозиті, використовуючи публічний ключ власника, bump, ID програми та унікальний рядок "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Ключова відмінність при виведенні коштів полягає в тому, що нам потрібно підписати транзакцію самим PDA. Для цього нам потрібно надати насіння, яке використовувалося для отримання PDA. Ми створюємо масив `SolSignerSeedsC` з двома елементами:
- Публічний ключ власника (32 байти)
- Bump (1 байт)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Потім ми створюємо інструкцію переказу System Program, але цього разу з сховища власнику. Дані інструкції такі ж, як і при депозиті:
- Чотирибайтовий дискримінатор (значення 2 для переказу)
- Вісім байтів для суми (яку ми отримуємо з лампортів сховища)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Мета-дані облікових записів змінені порівняно з депозитом:
- Перший обліковий запис — сховище (доступний для запису, підписант)
- Другий обліковий запис — власник (доступний для запису)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Нарешті, ми викликаємо `sol_invoke_signed_c` з інструкцією, інформацією про облікові записи та насінням підписанта, яке ми створили раніше:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Заключні зауваження" id="closing-remarks" level="h2" />

Хоча такий низькорівневий підхід до написання програм Solana може здаватися екстремальним, він виконує важливу освітню мету. Ми не пропонуємо вам писати програми таким чином; насправді, ми наполегливо рекомендуємо використовувати усталені фреймворки та крейти, які абстрагують ці складності. Однак розуміння базових механізмів є безцінним.

Кожна абстракція, яку ми використовуємо в розробці на Solana, будь то `solana_program`, `anchor`, чи будь-який інший фреймворк, побудована на цих фундаментальних будівельних блоках. Знімаючи шари та вивчаючи базову механіку, ми отримуємо глибше розуміння:

1. Як середовище виконання Solana взаємодіє з нашими програмами
2. Чому певні проєктні рішення були прийняті у фреймворках вищого рівня
3. Де можуть існувати потенційні оптимізації
4. Як краще налагоджувати проблеми, коли вони виникають

Ці знання не просто теоретичні; вони практичні. Коли ви розумієте основу, ви можете:
- Писати ефективніші програми, приймаючи обґрунтовані рішення щодо структур даних та використання пам'яті
- Краще діагностувати та виправляти проблеми, коли вони виникають
- Робити внесок в екосистему, вдосконалюючи інструменти, які ми всі використовуємо
- Приймати обґрунтовані рішення про те, коли використовувати певні абстракції, а коли працювати ближче до металу

Пам'ятайте, метою цієї вправи було не навчити вас писати програми без крейтів, а допомогти зрозуміти, що ці крейти роблять під капотом. Це розуміння є першим кроком до написання кращих, ефективніших програм для Solana, незалежно від того, які інструменти ви вирішите використовувати.
