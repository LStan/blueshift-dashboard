import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 区块链基础

现在您已经了解了为什么分布式系统本质上很难，以及为什么拜占庭将军问题似乎无法解决，让我们来探讨区块链实际上是如何工作的。

突破来自于结合了两个关键创新：新颖的共识机制和巧妙使用加密原语。

<ArticleSection name="共识机制" id="consensus-mechanisms" level="h2" />

计算机科学家实际上在 1980 年代通过数学方法解决了拜占庭将军问题，证明了要容忍 f 个叛徒，您至少需要 `3f+1` 个参与者。

考虑一个经典案例：四个将军中有一个叛徒。如果指挥将军是叛徒，他可能会告诉两个将军“进攻”，告诉另一个将军“撤退”。如果将军们仅仅遵循命令，计划将失败。解决方案需要额外一轮通信，在这一轮中，所有将军相互报告他们收到的命令。

这额外的通信轮次揭示了指挥官的欺骗行为。每个忠诚的将军都会看到“进攻”是多数命令（2 比 1），并据此行动。因为所有忠诚的将军得出了相同的结论，达成了共识，叛徒被击败。

背后的数学解决方案是可行的，但不实用：
- 您必须提前确切知道所有参与者是谁
- 每对参与者之间需要多轮消息传递
- 通信复杂性呈指数增长
- 在无许可系统中，攻击者可以创建无限的虚假身份

为了解决这个问题，区块链不再计算身份，而是计算难以伪造的东西：计算工作量或质押的资金。

### 工作量证明 (POW)

在 POW 系统中，为了提议接下来应该发生什么，您必须证明您完成了昂贵的计算工作：
- 矿工将待处理的交易收集到一个“区块”中
- 矿工必须找到一个随机数（称为“随机数”），当与区块数据结合并进行哈希运算时，产生以多个零开头的结果
- 第一个找到该数字的矿工将其解决方案广播到网络
- 其他参与者可以立即验证解决方案的正确性并接受新区块

这是可行的，因为找到随机数可能需要数万亿次随机猜测，但验证解决方案只需几毫秒。

每个区块还引用了前一个区块的哈希值，从而形成了一条链。要篡改历史，攻击者需要重新完成所有后续的计算工作，而诚实的矿工会继续扩展真实的链。

安全假设是攻击的电力成本高于攻击者可能获得的收益。

### 权益证明（Proof of Stake）

在 POS 系统中，与其消耗电力，参与者将自己的资金置于风险之中：
- 参与者将加密货币代币锁定作为抵押
- 协议根据其权益随机选择验证者提议区块
- 被选中的验证者提议区块，其他验证者投票接受或拒绝
- 诚实行为会获得奖励；不诚实行为会导致“削减”，即部分质押的代币被没收或罚没。具体的惩罚因网络和违规程度而异。

这是可行的，因为验证者有“利益相关”。攻击网络会破坏其质押代币的价值（通过削减）。此外，与工作量证明不同，权益证明可以提供经济终局性。一旦区块被绝大多数验证者最终确定，攻击者要想逆转它，就需要证明性地销毁大量资本，使得逆转成本高得无法承受。

### 区块链三难问题

正如分布式系统面临 CAP 定理，区块链也面临自身的不可能权衡。区块链三难问题指出，区块链共识最多只能优化以下三个属性中的两个：
- 安全性：抵抗攻击和审查的能力
- 可扩展性：高交易吞吐量
- 去中心化：没有单一控制点

比特币选择了安全性和去中心化，而不是可扩展性。像 Visa 这样的传统支付系统选择了可扩展性和安全性，而不是去中心化。当前的挑战是找到同时实现这三者的方法。

<ArticleSection name="Cryptographic Primitives" id="cryptographic-primitives" level="h2" />

共识机制解决了“谁来决定”的问题，但我们如何确保数据本身是可信的呢？

这就是密码学原语的作用所在：这些是经过数十年验证的数学工具。

区块链依赖于三种关键的密码学工具，它们协同工作以创建一个不可篡改且可验证的系统：

### 哈希函数

想象一下，你需要验证一份庞大的文档没有被篡改，但你只能发送一小段信息来证明。这正是哈希函数所实现的功能。

哈希函数可以将任何输入（无论是“Hello”这个词、莎士比亚的全集，还是包含数千笔交易的区块）转换为固定大小的输出，这个输出是一个独特的数字指纹。

哈希函数具有三个关键属性：

- **确定性：** 相同的输入总是会产生相同的输出。
- **不可逆性：** 该函数在一个方向上易于计算，但在反方向上计算几乎不可能。给定一个哈希值，你无法轻易找到原始输入，除非通过暴力破解或查找表。
- **雪崩效应：** 输入的微小变化（例如将一个字母大写）会导致完全不同的输出哈希值。

以下是一些 SHA-256 哈希值，展示了雪崩效应：

```plaintext
SHA-256("Hello") = 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969
SHA-256("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
```

注意，仅仅改变一个字母的大小写就会生成完全不同的哈希值。

虽然从任何输入计算哈希值是很简单的，但逆向过程在计算上是不可能的。给定一个哈希值，你无法推断出原始输入是什么，因为对于一个安全的哈希函数来说，这需要比宇宙的年龄还长的时间。

在区块链中，哈希用于确保数据的完整性。每个区块都包含前一个区块的哈希值，从而形成一个不可破坏的链条。如果有人试图修改上周的一笔交易，他们会改变该区块的哈希值。由于下一个区块引用了旧的哈希值，这种修改会破坏链条。要修复这一点，他们需要重新计算每个后续区块的哈希值，同时网络还在不断添加新的区块，这几乎是一个不可能完成的追赶游戏。

### 数字签名

传统的身份验证依赖于共享的秘密信息（如密码），但区块链在没有可信机构或安全渠道来共享秘密信息的情况下运行。因此，它们使用数字签名，这种方法可以在不泄露任何秘密信息的情况下实现身份验证。

数字签名使用非对称加密技术，这种技术依赖于一种数学关系：在一个方向上计算很容易，但几乎不可能反向计算。当您创建数字签名时，您会生成两个数学相关的数字，称为私钥和公钥；私钥必须保密，而公钥可以自由共享。

- 私钥可用于为特定交易创建数字签名。
- 签名是您私钥和确切交易内容的唯一组合。
- 任何人都可以使用您的公钥验证签名只能由拥有相应私钥的人创建。

没有您的私钥，即使拥有数百万个以前的签名，也无法计算出有效的签名。为了防止攻击者重放旧交易，每个签名必须包含一段唯一的数据，通常是一个简单的计数器，称为“随机数”（nonce），以确保每个签名都是唯一的。

这就创造了“不可抵赖性”：一旦您签署了一笔交易，就无法声称您没有授权它。数学证明是无可辩驳的。

在区块链中，这就是钱包的工作原理。您的“钱包”并不存储加密货币；这些币作为区块链上的条目存在。相反，钱包存储私钥，并帮助创建数字签名以证明您可以使用这些币。它们本质上是数字签名管理器。

### 默克尔树

如何在包含数千笔交易的区块中验证特定交易的存在，而无需下载整个区块？

默克尔树以二叉树的形式组织数据，其中每个叶子代表一笔交易，每个父节点包含其两个子节点的哈希值。这种结构一直延续到树的顶部，最终形成一个代表整个数据集的根哈希值。

因此，要证明树中存在任何交易，您只需要该交易和“默克尔路径”：用于重建根的兄弟节点哈希值。这意味着对于包含一百万笔交易的树，您只需要大约 20 个哈希值即可证明包含性。

在区块链中，默克尔树使得仅凭几千字节的证明就能极其轻松地验证交易。安全性保证保持不变：如果默克尔路径验证正确，您可以在数学上确定该交易已包含在该区块中。

<ArticleSection name="创建一个无需信任的系统" id="the-creation-of-a-trustless-system" level="h2" />

共识和加密原语共同作用，创建了一个“无需信任”的系统。历史上首次，信任被放在数学而非人身上：
- 哈希函数确保任何对历史数据的篡改都会立即显现。
- 数字签名在无需任何可信中介验证身份的情况下证明授权。
- 默克尔树使得无需下载大量数据即可验证复杂声明成为可能。

当结合共识机制时，这些工具创建了一个系统，每个参与者都可以仅使用自己的计算资源独立验证系统的整个历史记录。无需可信权威机构，无需共享秘密，也没有中心化的故障点。

这就是区块链代表如此根本性变革的原因。传统系统通过控制访问和限制参与来实现安全性。而区块链通过使验证变得廉价且普遍，同时使欺诈变得昂贵且显而易见来实现安全性。

理解这些基础要素至关重要，因为它们定义了区块链的能力和局限性。它们解释了为什么区块链交易是不可逆的（设计上使得逆转已完成交易的经济成本极高），为什么区块链系统可以在没有中心化权威的情况下运行（每个人都可以独立验证所有内容），以及为什么即使完全向公众开放参与，系统仍然保持安全。