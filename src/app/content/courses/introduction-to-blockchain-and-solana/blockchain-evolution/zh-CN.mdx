import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 区块链的演变

现在您已经了解了共识机制和密码学原理的工作方式，让我们来探讨这些概念如何从比特币的简单价值转移演变到今天的可编程区块链平台。

每个主要的区块链都代表了不同的工程决策和权衡，这些决策和权衡受我们所了解的基本约束所影响。

<ArticleSection name="Bitcoin" id="bitcoin" level="h2" />

比特币并不是为了成为通用计算机而设计的；它的目标是解决一个特定的问题：创建一种无需银行或政府运作的数字货币。比特币的每一个设计决策都反映了这一单一目标。

### 共识

比特币使用了中本聪设计的原始工作量证明（Proof of Work）实现。矿工们竞争寻找一个随机数（nonce），当与区块数据一起哈希时，会生成一个以特定数量的零开头的哈希值。

网络每隔 2,016 个区块（大约两周）会自动调整难度，以保持平均区块时间为 10 分钟。

这个时间设定并非随意。更快的区块会导致网络分裂，矿工在不同的区块链版本上工作。而更慢的区块会使交易变得非常缓慢。

### UTXO 模型

比特币不像银行那样追踪账户余额。相反，它通过 UTXO（未花费交易输出）来追踪单个“币”，其功能类似于实体现金。

想象一下，您的钱包里有三张 20 美元的钞票，您想买一件价值 35 美元的商品。您无法拆分一张 20 美元的钞票，因此您给收银员两张钞票（40 美元），并收到 5 美元的找零。比特币的运作方式完全相同：

假设 Alice 通过三笔独立的交易收到了比特币：
- UTXO #1: 0.5 BTC（来自 Bob）
- UTXO #2: 0.3 BTC（来自 Carol）
- UTXO #3: 0.8 BTC（来自 Dave）

Alice 的 "余额" 是 1.6 BTC，但并没有一个单一账户存储这个数字。相反，区块链记录了 Alice 可以使用的三个独立的 UTXO。

当 Alice 想要发送 1.0 BTC 给 Eve 时，她需要：
- 选择总额至少为 1.0 BTC 的 UTXO（她选择了 UTXO #1 和 #3，总计 1.3 BTC）
- 创建一笔交易，将 1.0 BTC 发送给 Eve，并将 0.3 BTC 作为找零返回给自己
- 使用她的私钥签署交易，以证明她拥有输入的 UTXO

该交易消耗了 UTXO #1 和 #3（它们现在被 "花费" 了），并创建了两个新的 UTXO：一个给 Eve，另一个找零 UTXO 给 Alice。

这种模型实现了强大的功能：
- 并行处理：由于每个 UTXO 只能被花费一次，使用不同 UTXO 的交易不会发生冲突。矿工可以同时验证数千笔交易，只要每笔交易引用的 UTXO 不同，就无需担心双重花费。
- 隐私：没有一个全局账户会显示你的总余额。你的比特币分散在多个 UTXO 中，使观察者更难确定你的总财富。每个 UTXO 可能与不同的地址相关联，进一步模糊了所有权模式。
- 简单验证：每笔交易可以通过独立验证输入的 UTXO 是否存在且未被花费，以及数字签名是否有效来完成。你无需维护复杂的账户状态，也无需担心交易顺序对余额的影响。
- 原子操作：交易要么完全成功（消耗所有输入并创建所有输出），要么完全失败。不存在部分状态的风险，例如部分资金被扣除但未转移的情况。

<ArticleSection name="Ethereum" id="ethereum" level="h2" />

比特币解决了数字支付的问题，而 Vitalik Buterin 发现了一个更大的机会：如果区块链不仅能转账，还能运行任何程序会怎样？这一愿景促成了以太坊的诞生：第一个通用的区块链计算机。

比特币的 UTXO 模型在支付方面表现完美，但对于需要持久状态、复杂逻辑以及不同程序之间可组合性的复杂应用来说显得笨拙。

### 共识机制

以太坊最初使用工作量证明（Proof of Work），但在 2022 年通过“合并”（The Merge）切换到了权益证明（Proof of Stake）。这一转变在保持安全性的同时带来了重要的优势：
- 数学终局性：大约 13 分钟后，交易变得数学上不可逆
- 能源效率：不再需要大量电力消耗
- 未来升级：权益证明支持分片技术，将网络分成并行链以提高吞吐量

### 账户模型

以太坊用更为熟悉的基于账户的余额系统取代了比特币的 UTXO 系统，从而实现了：
- 智能合约：驻留在区块链上的程序，能够维护自己的状态
- 外部账户：类似于比特币地址的用户控制账户
- 合约间调用：智能合约可以无缝地相互交互

在以太坊中，有两种类型的账户：
- 外部拥有账户（EOA）：由用户通过私钥控制，类似于比特币地址。它们有余额并可以发送交易。
- 合约账户：由代码控制，而非私钥。它们既有余额，也存储可执行代码和持久数据。

因此，在以太坊上，智能合约是驻留在区块链上的自治程序，能够维护自己的状态，并可以被其他账户调用。

这种账户模型支持持久状态——跨交易存活的数据。智能合约可以记住先前交互的信息，维护复杂的数据结构，并随着时间推移而演变。

这使得像借贷协议、治理系统和复杂金融工具这样的应用成为可能。

所有这些都得益于以太坊虚拟机 (EVM)，它运行在每个节点上，使区块链具有可编程性。EVM 定义了可以运行的程序、它们的执行方式以及它们消耗的资源。

<ArticleSection name="Solana" id="solana" level="h2" />

以太坊证明了区块链可以支持通用计算，但这一成功也暴露了可扩展性限制。随着去中心化应用的普及，网络拥堵导致了高昂的交易费用和较慢的确认时间。

这些限制源于以太坊设计中的基本架构决策，而 Solana 试图通过从基础原则重新设计核心区块链组件的架构创新来解决这些问题。

### 共识机制

Solana 使用权益证明 (Proof of Stake)，但增加了一项关键创新：历史证明 (Proof of History)。Solana 不需要等待事件发生时间的共识，而是创建了一个加密时钟，在共识之前为所有交易加上时间戳，使验证者能够并行处理交易，因为他们已经知道正确的顺序。

这种时间排序使得共识速度更快：Solana 每 400 毫秒生成一个区块，而以太坊需要 12 秒。

### Solana 虚拟机

EVM 按顺序处理交易，因为智能合约共享全局状态：当一个合约修改共享数据时，所有其他交易必须等待。这在网络使用量增长时会造成瓶颈。

Solana 从根本上重新思考了这一架构：
- 无状态程序：与以太坊智能合约内部存储数据不同，Solana 的程序是无状态的。所有数据存储在独立的账户中，程序从中读取和写入。这种分离使得并行处理成为可能，因为程序不需要争夺共享状态。
- 交易并行化：Solana 的交易必须提前声明将读取和修改哪些账户。运行时可以同时在多个 CPU 核心上执行不冲突的交易。如果交易 A 修改账户 X，而交易 B 修改账户 Y，它们可以并行运行。
- 优化执行：SVM 使用基于寄存器的架构，而不是 EVM 的基于堆栈的方式，从而减少了计算过程中数据移动的开销。程序编译为本地机器码，而不是字节码，消除了解释的开销。
- 可预测的成本：与以太坊多年前确定的固定 Gas 价格不同，Solana 使用动态费用市场，交易成本反映了实际的网络需求和消耗的计算资源。

Solana 的结果是能够处理每秒超过 5,000 笔交易（TPS），而以太坊仅为 15 TPS，同时保持亚秒级的最终确认时间和去中心化。这种性能得益于架构设计上的决策，优先采用并行执行，而非从单线程计算继承的顺序处理模型。