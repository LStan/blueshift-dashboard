import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Passkeys on Solana

<ArticleSection name="What is a Passkey" id="what-is-a-passkey" level="h2" />

Passkeys are the next generation of authentication technology that replace passwords with biometric authentication. Instead of remembering complex passwords or managing seed phrases, users authenticate using:

- **Face ID** or **Touch ID** on mobile devices
- **Windows Hello fingerprin**t or **facial recognition**
- **Hardware security keys** like YubiKey
- **PIN codes** as a fallback option

Think of passkeys as your biometric signature that proves it's really you, but cryptographically secure and impossible to forge.

### Solving the Web3 Authentication Challenge

Web3's reliance on seed phrases creates a fundamental barrier to adoption. Traditional wallet onboarding sees 60-80% user drop-off rates because of it.

The Problem is that Seed phrases demand perfect security from imperfect humans. Users must memorize 12-24 random words, store them safely forever, and never fall victim to phishing; an impossible standard for mainstream adoption.

The Solution could finally be Passkeys; they eliminate human error by moving private keys into dedicated security hardware. 

Users authenticate with familiar biometrics while cryptographic operations happen invisibly in secure enclaves.

<ArticleSection name="Passkeys on Solana" id="passkeys-on-solana" level="h2" />

Solana offers native support for passkey authentication through its built-in `secp256r1` signature verification precompile introduced with [SIMD-0075](https://github.com/solana-foundation/solana-improvement-documents/pull/75) by [Orion](https://x.com/BasedOrion_). 

This eliminates the need for complex bridging solutions or additional smart contract overhead since we can finally use a mix of passkeys and PDAs to actually manage users actions.

### Technical Implementation 

Passkeys use the `secp256r1` elliptic curve (NIST P-256), the same standard employed by WebAuthn and major tech platforms. The SDK provides clean abstractions through core data structures:

```rust
// 33-byte compressed public key (1 byte parity + 32 byte x-coordinate)
pub type Secp256r1Pubkey = [u8; 33];
// 64-byte signature (r,s values)
pub type Secp256r1Signature = [u8; 64];

// Main instruction parser
pub struct Secp256r1Instruction<'a> {
    header: Secp256r1InstructionHeader,    // Number of signatures
    offsets: &'a [Secp256r1SignatureOffsets], // Data location pointers
    data: &'a [u8],                        // Raw instruction data
}
```

The `Secp256r1SignatureOffsets` struct acts as a memory map, containing byte offsets that point to where each component lives within the instruction payload:

```rust
pub struct Secp256r1SignatureOffsets {
    pub signature_offset: u16,
    pub signature_instruction_index: u16,
    pub public_key_offset: u16,
    pub public_key_instruction_index: u16,
    pub message_data_offset: u16,
    pub message_data_size: u16,
    pub message_instruction_index: u16,
}
```

In the data, we find the three `Secp256r1` critical components referenced by the offset structure:
- Publickey: The 33-byte compressed `secp256r1` public key extracted from the user's passkey during `WebAuthn` registration. This represents the cryptographic identity of the authenticating device/user.
- Signature: The 64-byte `ECDSA` signature (r,s values) generated by the passkey's private key. This proves that the holder of the corresponding private key authorized the specific message.
- Message Data: The arbitrary bytes that were cryptographically signed. In practice, this contains application-specific data like transaction details, timestamps, or user identifiers that prevent replay attacks and ensure signatures are contextually bound.

As you can see, the publickey is 33 byte long because it uses a compressed point representation; a space-efficient encoding of elliptic curve points. 

On secp256r1, a public key is mathematically a point (x,y) where both coordinates are 32 bytes (64 bytes total). 

However, given any x-coordinate, only two possible y-coordinates satisfy the curve equation. 

The compressed format stores the 32-byte x-coordinate plus a single parity byte (0x02 for even y, 0x03 for odd y), allowing full point reconstruction with 48% less storage

### Architectural Implementation 

Programs can verify passkey signatures by parsing the instruction sysvar and calling `Secp256r1Instruction::try_from()` on `secp256r1` instructions found in the same transaction. 

The library handles all offset calculations and bounds checking, exposing simple methods like `get_signer()`, `get_signature()`, and `get_message_data()` to extract verified components.

### PDAs as wallets

As explained before, passkeys enable a revolutionary architecture where users don't need traditional wallets at all. 

Applications can now derive Program Derived Addresses (PDAs) directly from passkey public keys, creating deterministic account addresses that users control through biometric authentication like this:

```rust
// Derive a unique account for each passkey
let (pda, bump) = find_program_address(
    &[
        &pubkey[0..1],              // Parity byte (0x02 or 0x03)
        &pubkey[1..33]              // X-coordinate (32 bytes)
    ], 
    &program_id
);
This approach transforms the user experience fundamentally. Instead of managing wallet software, users authenticate with their device biometrics to control on-chain accounts. The passkey becomes their "wallet"â€”a cryptographic identity that works across any application supporting the standard. Programs verify ownership by checking that secp256r1 signatures in the transaction match the pubkey used to derive the PDA, enabling secure account operations without traditional private key management.