import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Байт за байтом: анатомія програми без крейтів

![Image Test](/graphics/banners/research-crateless-program.png)

Якщо ви писали програму для Solana, ви точно використовували крейт на кшталт `solana_program`, `pinocchio` або фреймворк, який використовував один із цих крейтів під капотом, як-от `anchor`, `steel`...

Але чи замислювалися ви коли-небудь, що нам довелося б робити, якби цих крейтів не існувало? Ласкаво просимо до основ низькорівневого програмування, де ми створимо повністю власноруч написану програму Solana без використання крейтів.

<ArticleSection name="Основи низькорівневого програмування Solana" id="low-level-solana-101" level="h2" />

Перш ніж засукати рукави та власноруч створити повний приклад сховища, нам потрібно зрозуміти кілька фундаментальних речей про програми Solana

#### `[repr(C)]` та `extern C`

Коли ви дивитеся на будь-який низькорівневий приклад Solana, два патерни з'являються знову і знову:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

- `extern "C"` вказує компілятору Rust експортувати (або очікувати) символ, який відповідає ABI мови C; це угода про виклики, яка визначає, які регістри eBPF містять аргументи, як організований стек і який регістр повертає значення.
- `#[repr(C)]` змушує Rust розташовувати структуру точно так, як це зробив би компілятор C, фіксуючи порядок полів і вирівнювання, щоб байтове розташування ніколи не змінювалося

Чому обрано саме ABI мови C? Тому що це найменший спільний знаменник для всіх мов, які підтримує бекенд eBPF від LLVM: Rust, C, Zig чи навіть асемблер, написаний вручну. Незалежно від того, який інструментарій створює байткод, середовище виконання Solana повинно викликати функцію входу вашої програми за її назвою та помістити три вказівники у відповідні регістри; дотримання ABI мови C гарантує, що це працюватиме для коду, створеного будь-якою мовою на основі LLVM.

#### Точка входу 

`entrypoint!()` є єдиним символом, який кожна програма Solana повинна експортувати. Це точка передачі, де середовище виконання Solana переходить від завантажувача до вашого коду.

Перед переходом завантажувач упаковує все, що потрібно для інструкції, в один плоский запис у стилі C, який зберігається на вхідній сторінці віртуальної машини BPF. Потім макрос розпаковує цей запис і передає вашому Rust три безпечні зрізи та посилання:
- **program_id**: публічний ключ програми, яка зараз виконується.
- **accounts**: вказівник на суцільний масив записів AccountInfo, плюс довжина.
- **instruction_data**: зріз вказівник-плюс-довжина необроблених байтів, наданих транзакцією.

Макрос буде:
- Перетворювати ці необроблені вказівники на безпечні зрізи Rust.
- Перехоплювати паніки, щоб вони ставали чистими кодами `ProgramError::Custom` замість аварійного завершення віртуальної машини.
- Передавати все до визначеної користувачем функції (часто називається `process_instruction`), яка повертає `ProgramResult`.

Ось опис єдиного плоского запису, який завантажувач Solana розміщує на вхідній сторінці віртуальної машини BPF перед переходом до вашої точки входу.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`: кількість надісланих облікових записів.
- `account_info`: необроблені записи облікових записів в інструкції, один за одним.
- `instruction_len`: скільки байтів даних інструкції йде далі.
- `instruction_data`: сама інструкція
- `program_id`: 32-байтовий `Pubkey` програми, яка виконується.

Кожен елемент масиву `account_info` потім має таку ж упаковану структуру:

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`: переконайтеся, що не "повторно десеріалізуєте" дані, якщо той самий обліковий запис з'являється в списку більше одного разу, пропускаючи його. `0xFF` означає "унікальний"; будь-яке інше значення - це індекс, який він копіює.
- `is_signer` / `is_writable` / `executable`: однобайтові прапорці, які середовище виконання використовує, щоб ваша програма могла контролювати логіку та CPI без додаткових системних викликів.
- `alignment`: Чотирибайтовий заповнювач, який зберігає вирівнювання всієї структури по 8 байтів. Pinocchio перепризначає його для відстеження початкової довжини даних під час перерозподілу пам'яті.
- `key` / `owner` / `lamports`: Мінімально необхідні дані, які повинен мати кожен обліковий запис.
- `data_len` + `data`: Дані змінної довжини, які може мати обліковий запис.
- `padding`: Завантажувач попередньо виділяє 10_240 байтів, максимальний розмір облікового запису, щоб дані облікового запису могли змінюватися та зростати на місці без переміщення пам'яті.
- `align_padding`: Додатковий заповнювач, якщо потрібно, щоб наступний `AccountRaw` все ще починався на межі 8 байтів (важливо для деяких хостів eBPF).
- `rent_epoch`:	Епоха, коли обліковий запис повинен наступного разу сплатити ренту; зберігається для сумісності, навіть якщо збір ренти призупинено.

#### Системні виклики 

**Системний виклик**, або syscall, — це двері, через які непривілейований код запитує привілейовану послугу від свого хоста. Коли здійснюється системний виклик, процесор переходить з режиму користувача в довірений, привілейований режим; середовище виконання потім виконує запитану дію, і керування повертається зі статусним кодом. Це опосередкування не дозволяє ізольованому коду безпосередньо взаємодіяти з пам'яттю хоста або вводом-виводом, зберігаючи безпеку та детермінізм.

У Solana, байткод BPF не може самостійно хешувати, логувати або виконувати міжпрограмний виклик (CPI). Натомість він викликає іменовані системні виклики, такі як `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Кожен номер системного виклику — це просто індекс у таблиці диспетчеризації завантажувача. Завантажувач виконує запитану операцію і повертає статусне слово `u64` (нуль для успіху, ненульове значення для невдачі).

Наприклад, `sol_invoke_signed` упаковує інструкцію, її список облікових записів та будь-які насіння підписувача PDA, передає їх завантажувачу, і завантажувач виконує CPI під відповідними повноваженнями таким чином:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Код сховища" id="the-vault-code" level="h2" />

Тепер, коли ми розібрали кожен будівельний блок програми Solana "без крейтів", ми можемо окреслити саме сховище. Пам'ятайте, сховище робить рівно дві речі:
- **Депозит** лампортів у PDA, отриманий з публічного ключа власника.
- **Вивід** тих самих лампортів пізніше; тільки власником.

Кожна інструкція, таким чином, міститиме три облікові записи:
- **Власник** (підписувач, доступний для запису): Користувач, який вносить або виводить кошти.
- **Сховище** (доступне для запису): PDA, де містяться всі лампорти.
- **Системна програма**: обліковий запис, необхідний для здійснення переказу лампортів.

Перед початком нам потрібно створити новий проєкт, для цього виконайте цю команду в терміналі:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

У `Cargo.toml` додайте:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Шаблон 

Все буде знаходитися в `lib.rs`. Загалом, файл міститиме Syscall Shims (маленькі структури #[repr(C)], які відображають макети сирих системних викликів, які нам знадобляться) та зміщення даних як константи (щоб полегшити роботу з необробленими даними).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Перевірки облікових записів

Перш ніж ми зможемо запустити `deposit` або `withdraw`, точка входу має переконатися, що транзакція надала нам саме ті облікові записи, які потрібні, і що кожен з них має очікувані прапорці.

Оскільки ми працюємо на рівні сирих вказівників, кожна перевірка виконується за допомогою простої арифметики вказівників і прямого завантаження.

Перші вісім байтів вхідного запису містять account_len. Для цього сховища ми очікуємо три облікові записи: власник, PDA сховища та System Program:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Ми продовжуємо перевіркою кожного облікового запису, зміщення макета, які ми визначили раніше, дозволяють нам перевірити кожен прапорець без десеріалізації повної структури.

Для першого облікового запису, підписувача, ми виконуємо такі перевірки: 
- Має бути унікальним (is_duplicate == 0xff)
- Доступний для запису (ми змінимо його ламперти)
- Підписувач
- Не виконуваний
- Не повинен мати даних 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Ми також зберігаємо відкритий ключ власника для подальшої перевірки PDA:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Для другого облікового запису, сховища, ми виконуємо такі перевірки:
- Доступний для запису (ми змінимо його ламперти)
- Належить System Program
- Довжина даних має бути нульовою (ми не зберігаємо стан тут)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Ми також отримуємо відкритий ключ сховища для подальшої перевірки PDA:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Для останнього облікового запису, системної програми, ми виконуємо такі перевірки: 
- Має бути виконуваним
- Його ключ повинен дорівнювати SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Перевірка інструкцій

Після валідації облікового запису ми нарешті можемо розібрати корисне навантаження інструкції. І ми використовуємо той самий підхід, що й нативна програма, використовуючи перший байт як дискримінатор:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

Звідси ми переходимо або до обробника депозиту, або до обробника зняття коштів, впевнені, що кожен обліковий запис і прапорець точно відповідають очікуванням сховища.

#### Логіка депозиту

Ми почнемо з детального огляду інструкції депозиту. Усі перевірки розташовані на початку; після їх проходження ми створюємо переказ System-Program і викликаємо його.

Дані цієї інструкції виглядають так:
- Байт 0 — це дискримінатор (`0x00` для депозиту).
- Байт 1 — це bump, який ви повторно використовуватимете для перевірки PDA.
- Байти 2-9 містять кількість лампортів у форматі little-endian, яка буде перевірена і відхилена, якщо дорівнює 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Після цього ми хешуємо ключ власника за допомогою системного виклику `sol_sha256`, з bump, ідентифікатором програми та унікальним рядком "ProgramDerivedAddress".

Ми порівнюємо результат з ключем сховища, який ми зберегли під час перевірки облікового запису. Якщо вони відрізняються, повертається `InvalidSeeds`.

Якщо вони відрізняються, повертається `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Нарешті ми можемо створити переказ System-Program.

System Program використовує чотирибайтовий дискримінатор (для переказу це значення 2) і потребує додаткових 8 байтів, які представляють суму, яку ми хочемо перевести з `from_account` до `to_account`

Потім нам потрібно створити невеликий масив із двох значень SolAccountMeta: from = власник (підписант, доступний для запису), to = сховище (доступне для запису). Ми поєднуємо це з `instruction_data` для створення структури `SolInstruction`:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Але перед викликом системного виклику `sol_invoke_signed_c` нам потрібно створити дві структури `SolAccountInfo`, одну для власника та одну для
сховища, які надають вказівники на їхні баланси лампортів та зрізи даних саме там, де завантажувач залишив їх у пам'яті.

Після цього ми можемо викликати системний виклик, передавши вказівник на інструкцію, вказівник на ваш двоелементний масив `SolAccountInfo` та кількість облікових записів (2). Оскільки зовнішня транзакція вже підписана власником, насіння PDA тут не потрібне, тому аргумент `signers_seeds_addr` є NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Логіка зняття коштів

Інструкція зняття коштів подібна до депозиту, але з кількома ключовими відмінностями. Дані інструкції простіші:
- Байт 0 — дискримінатор (`0x01` для зняття).
- Байт 1 — це bump, який ви повторно використовуватимете для перевірки PDA.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Ми виконуємо таку ж перевірку PDA, як і при депозиті, використовуючи відкритий ключ власника, bump, ідентифікатор програми та унікальний рядок "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Ключова відмінність при знятті коштів полягає в тому, що нам потрібно підписати транзакцію самим PDA. Для цього нам потрібно надати насіння, яке використовувалося для отримання PDA. Ми створюємо масив `SolSignerSeedsC` з двома елементами:
- Відкритий ключ власника (32 байти)
- Bump (1 байт)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Потім ми створюємо інструкцію переказу для Системної Програми, але цього разу зі сховища власнику. Дані інструкції такі ж, як і при депозиті:
- Чотирибайтовий дискримінатор (значення 2 для переказу)
- Вісім байтів для суми (яку ми отримуємо з лампортів сховища)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Метадані облікових записів розташовані у зворотному порядку порівняно з депозитом:
- Перший обліковий запис — це сховище (з можливістю запису, підписант)
- Другий обліковий запис — це власник (з можливістю запису)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Нарешті, ми викликаємо `sol_invoke_signed_c` з інструкцією, інформацією про облікові записи та насінням підписанта, яке ми створили раніше:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Заключні зауваження" id="closing-remarks" level="h2" />

Хоча такий низькорівневий підхід до написання програм Solana може здаватися екстремальним, він виконує важливу освітню мету. Ми не пропонуємо вам писати програми таким чином; насправді, ми наполегливо рекомендуємо використовувати усталені фреймворки та крейти, які абстрагують ці складнощі. Однак розуміння базових механізмів є безцінним.

Кожна абстракція, яку ми використовуємо в розробці Solana, будь то `solana_program`, `anchor` чи будь-який інший фреймворк, побудована на цих фундаментальних будівельних блоках. Знімаючи шари та вивчаючи базові механізми, ми отримуємо глибше розуміння:

1. Як середовище виконання Solana взаємодіє з нашими програмами
2. Чому певні проєктні рішення були прийняті у фреймворках вищого рівня
3. Де можуть існувати потенційні оптимізації
4. Як краще налагоджувати проблеми, коли вони виникають

Ці знання не просто академічні; вони практичні. Коли ви розумієте основу, ви можете:
- Писати ефективніші програми, приймаючи обґрунтовані рішення щодо структур даних та використання пам'яті
- Краще діагностувати та виправляти проблеми, коли вони виникають
- Робити внесок в екосистему, покращуючи інструменти, які ми всі використовуємо
- Приймати обґрунтовані рішення про те, коли використовувати певні абстракції, а коли працювати ближче до металу

Пам'ятайте, метою цієї вправи було не навчити вас писати програми без крейтів, а допомогти зрозуміти, що ці крейти роблять під капотом. Це розуміння є першим кроком до написання кращих, ефективніших програм Solana, незалежно від того, які інструменти ви вирішите використовувати.
