import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# 字节解析：无 Crate 程序的结构剖析

![图像测试](/graphics/banners/research-crateless-program.png)

如果您曾经编写过一个 Solana 程序，那么您一定使用过类似 `solana_program`、`pinocchio` 的 crate，或者使用过一个在底层依赖这些 crate 的框架，比如 `anchor`、`steel`...

但您是否想过，如果这些 crate 不存在，我们需要做些什么？欢迎来到低级编程 101，我们将创建一个完全手工编写、无 crate 的 Solana 程序。

<ArticleSection name="低级 Solana 101" id="low-level-solana-101" level="h2" />

在我们撸起袖子手工编写一个完整的 vault 示例之前，我们需要了解一些关于 Solana 程序的基本知识

#### `[repr(C)]` 和 `extern C`

当您查看任何低级 Solana 示例时，会反复出现两种模式：

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

- `extern "C"` 告诉 Rust 编译器暴露（或期望）一个遵循 C ABI 的符号；这种调用约定定义了哪些 eBPF 寄存器携带参数、堆栈如何布局以及哪个寄存器返回值。
- `#[repr(C)]` 强制 Rust 按照 C 编译器的方式排列结构体，锁定字段顺序和填充，以确保字节布局永远不会改变。

为什么选择 C ABI？因为它是 LLVM 的 eBPF 后端支持的每种语言（如 Rust、C、Zig，甚至是手写汇编）的最低公分母。无论哪个工具链生成字节码，Solana 运行时都需要通过原始名称调用您的程序入口函数，并将三个指针放入正确的寄存器中；遵循 C ABI 可以保证任何基于 LLVM 的语言生成的代码都能正常工作。

#### 入口点

`entrypoint!()` 是每个 Solana 程序必须公开的唯一符号。它是 Solana 运行时从加载器跳转到您的代码的交接点。

在跳转之前，加载器会将指令所需的所有内容打包成一个扁平的 C 风格记录，并存储在 BPF VM 的输入页面上。然后宏会解包该记录，并为您的 Rust 提供三个安全的切片和引用：
- **program_id**：当前正在执行的程序的 pubkey。
- **accounts**：指向 AccountInfo 记录连续数组的指针，以及一个长度。
- **instruction_data**：由交易提供的原始字节的指针加长度切片。

该宏将：
- 将这些原始指针转换为安全的 Rust 切片。
- 捕获 panic，使其成为干净的 `ProgramError::Custom` 代码，而不是导致 VM 崩溃。
- 将所有内容转发到用户定义的函数（通常称为 `process_instruction`），该函数返回一个 `ProgramResult`。

以下是 Solana 加载器在跳转到您的入口点之前放置在 BPF VM 输入页面上的单个扁平记录的描述。

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`：发送的账户数量。
- `account_info`：指令中的原始账户记录，一个接一个。
- `instruction_len`：后续指令数据的字节数。
- `instruction_data`：指令本身。
- `program_id`：正在运行的程序的 32 字节 `Pubkey`。

`account_info` 数组的每个元素随后遵循相同的打包布局：

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`：如果同一账户在列表中出现多次，通过跳过它确保不要重新反序列化数据。`0xFF` 表示“唯一”；任何其他值是它复制的索引。
- `is_signer` / `is_writable` / `executable`：运行时使用的单字节标志，使您的程序可以在没有额外系统调用的情况下控制逻辑和 CPI。
- `alignment`：一个占位的四字节 slot，用于保持整个结构的 8 字节对齐。Pinocchio 在重新分配期间将其重新用于跟踪原始数据长度。
- `key` / `owner` / `lamports`：每个账户应具有的最低可行数据。
- `data_len` + `data`：账户可能具有的可变长度数据。
- `padding`：加载器预分配 10,240 字节，这是账户的最大大小，因此账户数据可以在不移动内存的情况下原地更改和增长。
- `align_padding`：如果需要，额外的填充，以便下一个 `AccountRaw` 仍然从 8 字节边界开始（对于某些 eBPF 主机很重要）。
- `rent_epoch`：账户下次必须支付租金的 epoch；为了兼容性保留，即使租金收取已暂停。

#### 系统调用 

**系统调用**（syscall）是非特权代码向其主机请求特权服务的入口。当进行系统调用时，CPU 会从用户模式切换到受信任的特权模式；运行时随后执行请求的操作，并返回一个状态码以恢复控制。这种间接方式可以防止沙盒代码直接访问主机内存或 I/O，从而确保安全性和确定性。

在 Solana 上，BPF 字节码无法自行进行哈希、日志记录或执行跨程序调用（CPI）。相反，它会调用命名的系统调用，例如 `sol_log`、`sol_sha256`、`sol_invoke_signed`。

每个系统调用号只是加载器调度表中的一个索引。加载器执行请求的操作并返回一个 `u64` 状态字（成功为零，失败为非零）。

例如，`sol_invoke_signed` 会打包一个指令、其账户列表以及任何 PDA 签名者种子，将它们交给加载器，加载器在适当的权限下执行 CPI，如下所示：

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="The Vault Code" id="the-vault-code" level="h2" />

现在我们已经拆解了一个“无 crate” Solana 程序的每个构建块，我们可以概述保险库本身。请记住，保险库只执行两项操作：
- **存入** lamports 到从所有者公钥派生的 PDA 中。
- **提取**这些相同的 lamports；仅限所有者提取。

因此，每个指令将携带三个账户：
- **所有者**（签名者，可写）：存入或提取资金的用户。
- **保险库**（可写）：包含所有 lamports 的 PDA。
- **系统程序**：执行 lamport 转移所需的账户。

在开始之前，我们需要创建一个新项目，为此，请在终端中运行以下命令：

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

在 `Cargo.toml` 中添加：

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### 模板

所有内容都将存放在 `lib.rs` 中。简单来说，该文件将包含 Syscall Shims（小型的 #[repr(C)] 结构体，用于镜像我们需要的原始系统调用布局）和作为常量的数据偏移量（以便更轻松地处理原始数据）。

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### 账户检查

在运行 `deposit` 或 `withdraw` 之前，入口点必须确保交易提供了完全正确的账户，并且每个账户都具有预期的标志。

由于我们在处理原始指针级别的操作，每次检查都通过简单的指针运算和直接加载完成。

输入记录的前八个字节包含 account_len。对于这个 vault，我们期望有三个账户：所有者、vault PDA 和 System Program：

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

我们继续检查每个账户，之前定义的布局偏移量让我们可以在不反序列化完整结构的情况下对每个标志进行合理性检查。

对于第一个账户（签名者），我们执行以下检查：
- 必须是唯一的（is_duplicate == 0xff）
- 可写（我们将更改其 lamports）
- 签名者
- 不可执行
- 必须没有数据

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我们还会存储所有者的公钥，以便稍后进行 PDA 检查：

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

对于第二个账户（vault），我们执行以下检查：
- 可写（我们将更改其 lamports）
- 由 System Program 拥有
- 数据长度必须为零（我们不在此存储状态）

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我们还会获取 vault 的公钥，以便稍后进行 PDA 检查：

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

对于最后一个账户（System Program），我们执行以下检查：
- 必须是可执行的
- 其密钥必须等于 SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### 指令检查

在账户验证之后，我们终于可以解析指令的有效负载了。我们采用与原生程序相同的方法，使用第一个字节作为区分符：

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

从这里开始，我们分支到存款或取款处理程序，确信每个账户和标志都完全符合金库的预期。

#### 存款逻辑

我们将从存款指令的详细讲解开始。所有检查都在前面；一旦通过，我们就会创建一个 System Program 转账并调用它。

该指令的数据结构如下：
- 字节 0 是区分符（`0x00` 表示存款）。
- 字节 1 是您将用于 PDA 检查的 bump 值。
- 字节 2-9 以小端字节序存储 lamport 数量，如果为 0，将被检查并拒绝。

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

之后，我们使用 `sol_sha256` 系统调用对所有者密钥进行哈希处理，结合 bump 值、程序 ID 和唯一字符串 "ProgramDerivedAddress"。

我们将结果与账户检查期间存储的金库密钥进行比较。如果它们不同，则返回 `InvalidSeeds`。

如果它们不同，则返回 `InvalidSeeds`。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

最后，我们终于可以创建 System Program 转账了。

System Program 使用一个四字节的区分符（对于转账，该值为 2），并需要额外的 8 个字节来表示我们希望从 `from_account` 转账到 `to_account` 的金额。

然后我们需要构建一个包含两个 SolAccountMeta 值的小数组：from = owner（签名者，可写），to = vault（可写）。我们将其与 `instruction_data` 结合，创建一个 `SolInstruction` 结构体：

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

但在调用 `sol_invoke_signed_c` 系统调用之前，我们需要构建两个 `SolAccountInfo` 结构体，一个用于所有者，一个用于
金库，这些结构体提供指向其 lamport 余额和数据切片的指针，正好位于加载器在内存中留下的位置。

之后，我们可以通过传递指令指针、指向两个元素的 `SolAccountInfo` 数组的指针以及账户数量（2）来调用系统调用。由于外部交易已经由所有者签名，这里不需要 PDA seeds，因此 `signers_seeds_addr` 参数为 NULL。

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### 提现逻辑

提现指令与存款类似，但有一些关键区别。指令数据更简单：
- 字节 0 是区分符（提现为 `0x01`）。
- 字节 1 是您将用于 PDA 检查的 bump。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

我们执行与存款相同的 PDA 检查，使用所有者的公钥、bump、程序 ID 和唯一字符串 "ProgramDerivedAddress"：

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

提现的关键区别在于我们需要使用 PDA 本身签署交易。为此，我们需要提供用于派生 PDA 的 seeds。我们创建一个包含两个元素的 `SolSignerSeedsC` 数组：
- 所有者的公钥（32 字节）
- bump（1 字节）

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

然后我们构建 System Program 转账指令，但这次是从金库到所有者。指令数据与存款相同：
- 四字节区分符（转账的值为 2）
- 八字节金额（从金库的 lamports 中获取）

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

账户元数据与存款操作相比是反向的：
- 第一个账户是金库（可写，签名者）
- 第二个账户是所有者（可写）

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

最后，我们使用之前创建的指令、账户信息和签名种子调用 `sol_invoke_signed_c`：

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="总结" id="closing-remarks" level="h2" />

虽然这种编写 Solana 程序的低级方法看起来极端，但它具有重要的教育意义。我们并不是建议您以这种方式编写程序；事实上，我们强烈建议使用已建立的框架和库来抽象这些复杂性。然而，理解底层机制是非常有价值的。

我们在 Solana 开发中使用的每一个抽象，无论是 `solana_program`、`anchor`，还是其他任何框架，都是建立在这些基本构件之上的。通过剥开层次并检查原始机制，我们可以更深入地理解：

1. Solana 运行时如何与我们的程序交互
2. 为什么在高级框架中做出某些设计决策
3. 潜在的优化可能存在于何处
4. 当问题发生时如何更好地调试

这些知识不仅仅是学术性的；它们是实用的。当您理解了基础，您可以：
- 通过对数据结构和内存使用做出明智的决策来编写更高效的程序
- 在问题出现时更好地诊断和修复
- 通过改进我们共同使用的工具为生态系统做出贡献
- 在使用某些抽象和更接近底层操作之间做出明智的选择

请记住，这项练习的目标不是教您如何在没有库的情况下编写程序，而是帮助您理解这些库在底层的工作原理。这种理解是编写更好、更高效的 Solana 程序的第一步，无论您选择使用哪些工具。
