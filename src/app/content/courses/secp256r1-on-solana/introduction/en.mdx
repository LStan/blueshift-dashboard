import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Secp256r1 on Solana

![Secp256r1 on Solana](/graphics/course-banners/secp256r1-on-solana.png)

<ArticleSection name="What is Secp256r1" id="what-is-secp256r1" level="h2" />

Secp256r1 (also known as NIST P-256) is an elliptic curve that serves as the cryptographic foundation for modern authentication systems, including passkeys. This curve is widely used in WebAuthn and major tech platforms for secure authentication.

### The Web3 Authentication Challenge

Web3's reliance on seed phrases creates a fundamental barrier to adoption. Traditional wallet onboarding sees 60-80% user drop-off rates because of it.

The Problem is that Seed phrases demand perfect security from imperfect humans. Users must memorize 12-24 random words, store them safely forever, and never fall victim to phishing; an impossible standard for mainstream adoption.

The Solution could be modern authentication methods like passkeys, which eliminate human error by moving private keys into dedicated security hardware. However, to support these on Solana, we need the right cryptographic primitives.

<ArticleSection name="Secp256r1 on Solana" id="secp256r1-on-solana" level="h2" />

Solana offers native support for Secp256r1 signature verification through its built-in precompile introduced with [SIMD-0075](https://github.com/solana-foundation/solana-improvement-documents/pull/75) by [Orion](https://x.com/BasedOrion_).

This is a crucial step toward enabling modern authentication methods like passkeys on Solana, as Secp256r1 is the same elliptic curve used by WebAuthn and passkey implementations. With this support, we can finally use a mix of modern authentication methods and PDAs to manage user actions.

### Technical Implementation 

The Secp256r1 elliptic curve (NIST P-256) is the same standard employed by WebAuthn and major tech platforms. The SDK provides clean abstractions through core data structures:

```rust
// 33-byte compressed public key (1 byte parity + 32 byte x-coordinate)
pub type Secp256r1Pubkey = [u8; 33];
// 64-byte signature (r,s values)
pub type Secp256r1Signature = [u8; 64];

// Main instruction parser
pub struct Secp256r1Instruction<'a> {
    header: Secp256r1InstructionHeader,    // Number of signatures
    offsets: &'a [Secp256r1SignatureOffsets], // Data location pointers
    data: &'a [u8],                        // Raw instruction data
}
```

The `Secp256r1SignatureOffsets` struct acts as a memory map, containing byte offsets that point to where each component lives within the instruction payload:

```rust
pub struct Secp256r1SignatureOffsets {
    pub signature_offset: u16,
    pub signature_instruction_index: u16,
    pub public_key_offset: u16,
    pub public_key_instruction_index: u16,
    pub message_data_offset: u16,
    pub message_data_size: u16,
    pub message_instruction_index: u16,
}
```

In the data, we find the three critical components referenced by the offset structure:
- Publickey: The 33-byte compressed `Secp256r1` public key. When used with modern authentication methods like passkeys, this represents the cryptographic identity of the authenticating device/user.
- Signature: The 64-byte `ECDSA` signature (r,s values) generated by the private key. This proves that the holder of the corresponding private key authorized the specific message.
- Message Data: The arbitrary bytes that were cryptographically signed. In practice, this contains application-specific data like transaction details, timestamps, or user identifiers that prevent replay attacks and ensure signatures are contextually bound.

As you can see, the publickey is 33 byte long because it uses a compressed point representation; a space-efficient encoding of elliptic curve points. 

On Secp256r1, a public key is mathematically a point (x,y) where both coordinates are 32 bytes (64 bytes total).

However, given any x-coordinate, only two possible y-coordinates satisfy the curve equation. 

The compressed format stores the 32-byte x-coordinate plus a single parity byte (0x02 for even y, 0x03 for odd y), allowing full point reconstruction with 48% less storage.

### Architectural Implementation 

Programs can verify Secp256r1 signatures by parsing the instruction sysvar and calling `Secp256r1Instruction::try_from()` on `secp256r1` instructions found in the same transaction.

The library handles all offset calculations and bounds checking, exposing simple methods like `get_signer()`, `get_signature()`, and `get_message_data()` to extract verified components.

### PDAs as wallets

The Secp256r1 support enables a revolutionary architecture where users can authenticate using modern methods like passkeys.

Applications can derive Program Derived Addresses (PDAs) directly from Secp256r1 public keys, creating deterministic account addresses that users can control through modern authentication methods:

```rust
// Derive a unique account for each Secp256r1 public key
let (pda, bump) = find_program_address(
    &[
        &pubkey[0..1],              // Parity byte (0x02 or 0x03)
        &pubkey[1..33]              // X-coordinate (32 bytes)
    ], 
    &program_id
);
```

We need to split the pubkey in 2 different parts because seeds accept 32 bytes as maximum length.

This approach transforms the user experience fundamentally. Instead of managing traditional wallet software, users can authenticate using modern methods like passkeys to control on-chain accounts. 

The Secp256r1 public key becomes the foundation for their "wallet"; a cryptographic identity that works across any application supporting the standard.

Programs verify ownership by checking that Secp256r1 signatures in the transaction match the pubkey used to derive the PDA, enabling secure account operations without traditional private key management.

The only drawback of this approach is that the protocol needs to pay for all fees for the user.