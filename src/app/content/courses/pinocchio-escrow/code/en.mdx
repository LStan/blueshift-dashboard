import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

<ArticleSection name="The Escrow Program" id="the-escrow-program" level="h2" />

Now that we've covered every moving part we'll need, let's dive into the escrow logic itself.

An escrow lets one user lock up Token A in exchange for Token B from a second user. Our program therefore boils down to three instructions:
- **Make**: The maker defines the trade terms and deposits the agreed amount of Token A.
- **Take**: The taker accepts, transfers the promised Token B to the maker, and receives the locked Token A.
- **Refund**: The maker cancels the offer and pulls back the Token A they deposited.

Let's start by creating a fresh Rust environment:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

Add pinocchio, pinocchio-system, pinocchio-token and pinocchio-associated-token:

```
cargo add pinocchio pinocchio-system pinocchio-token pinocchio-associated-token-account
```

Declare the crate types in `Cargo.toml` to generate deployment artifacts in `target/deploy`:

```
[lib]
crate-type = ["lib", "cdylib"]
```

You’re now ready to write your escrow program.

<ArticleSection name="Template" id="entrypoint" level="h2" />

This time we'll split the program into small, focused modules instead of cramming everything into the `lib.rs`. The folder tree will look roughly like this:

```
src
├── instructions
│       ├── make.rs
│       ├── helpers.rs
│       ├── mod.rs
│       ├── refund.rs
│       └── take.rs
├── errors.rs
├── lib.rs
└── state.rs
```

The entrypoint, that lives in the `lib.rs` looks very similar to what we did in the last lessons so we're going to go over it very quickly:

<Codeblock lang="rust">
  ```rust
  use pinocchio::{account_info::AccountInfo, entrypoint, program_error::ProgramError, pubkey::Pubkey, ProgramResult};
  entrypoint!(process_instruction);

  pub mod instructions;
  pub use instructions::*;

  pub mod state;
  pub use state::*;

  // 22222222222222222222222222222222222222222222
  pub const ID: Pubkey = [
      0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07,
      0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee,
      0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07,
      0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7,
  ];

  fn process_instruction(
      _program_id: &Pubkey,
      accounts: &[AccountInfo],
      instruction_data: &[u8],
  ) -> ProgramResult {
      match instruction_data.split_first() {
          Some((Make::DISCRIMINATOR, data)) => Make::try_from((data, accounts))?.process(),
          Some((Take::DISCRIMINATOR, _)) => Take::try_from(accounts)?.process(),
          Some((Refund::DISCRIMINATOR, _)) => Refund::try_from(accounts)?.process(),
          _ => Err(ProgramError::InvalidInstructionData)
      }
  }
  ```
</Codeblock>

<ArticleSection name="Make" id="make" level="h2" />

The `make` instruction does three jobs:
- Initialises the Escrow record and stores all deal terms.
- Creates the Vault (an ATA for `mint_a` owned by the `escrow`).
- Moves the maker's Token A into that vault with a CPI to the SPL-Token program.

### Required Accounts

Below are the accounts the context needs:

- maker: the creator of the escrow. Must be a signer and mutable
- escrow: the escrow account that we're initializing. Must be mutable
- mint_a: the token we're depositing in the escrow
- mint_b: the token we want to receive
- maker_ata_a: the associated token account owned by the maker. Must be mutable
- vault: the associated token account owned by the escrow. Must be mutable
- associated_token_program: the associated token program. Must be executable
- token_program: the token program. Must be executable
- system_program: the system program. Must be executable

We're going to use the types that live in the `helper.rs` file that we discussed in the previous section.

In code, this looks like:

<Codeblock lang="rust">
  ```rust
  pub struct MakeAccounts<'a> {
      pub maker: &'a AccountInfo,
      pub escrow: &'a AccountInfo,
      pub mint_a: &'a AccountInfo,
      pub mint_b: &'a AccountInfo,
      pub maker_ata_a: &'a AccountInfo,
      pub vault: &'a AccountInfo,
      pub system_program: &'a AccountInfo,
      pub token_program: &'a AccountInfo,
  }

  impl<'a> TryFrom<&'a [AccountInfo]> for MakeAccounts<'a> {
      type Error = ProgramError;

      fn try_from(accounts: &'a [AccountInfo]) -> Result<Self, Self::Error> {
          let [maker, escrow, mint_a, mint_b, maker_ata_a, vault, system_program, token_program, _] = accounts else {
              return Err(ProgramError::NotEnoughAccountKeys);
          };

          // Basic Accounts Checks
          SignerAccount::check(maker)?;
          MintInterface::check(mint_a)?;
          MintInterface::check(mint_b)?;
          AssociatedTokenAccount::check(maker_ata_a, maker, mint_a, token_program)?;

          // Return the accounts
          Ok(Self {
              maker,
              escrow,
              mint_a,
              mint_b,
              maker_ata_a,
              vault,
              system_program,
              token_program,
          })
      }
  }
  ```
</Codeblock>

### Instruction Data

Here's the instruction data we need to pass in:
- seed: the random number used during seed derivation. Must be a u64
- receive: the amount that the maker wants to receive. Must be a u64
- amount: the amount that the maker wants to deposit. Must be a u64

We'll check to make sure the `amount` isn't zero, since that wouldn't make sense for an escrow.

Here's how it looks in code:

<Codeblock lang="rust">
  ```rust
  pub struct MakeInstructionData {
      pub seed: u64,
      pub receive: u64,
      pub amount: u64,
  }

  impl<'a> TryFrom<&'a [u8]> for MakeInstructionData {
      type Error = ProgramError;

      fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
          if data.len() != size_of::<u64>() * 3 {
              return Err(ProgramError::InvalidInstructionData);
          }

          let seed = u64::from_le_bytes(data[0..8].try_into().unwrap());
          let receive = u64::from_le_bytes(data[8..16].try_into().unwrap());
          let amount = u64::from_le_bytes(data[16..24].try_into().unwrap());

          // Instruction Checks
          if amount == 0 {
              return Err(ProgramError::InvalidInstructionData);
          }

          Ok(Self {
              seed,
              receive,
              amount,
          })
      }
  }
  ```
</Codeblock>

### Instruction Logic

Now we can move to the logic side of things. We're going to put all the account initialization into our `try_from` function; this is where we handle what would normally be done with Anchor's `init` or `init_if_needed` macros.

After initializing the Escrow and the Vault accounts, we can finally set the data inside the Escrow account and transfer the tokens from the `maker_ata_a` to the vault like this:

<Codeblock lang="rust">
   ```rust
  pub struct Make<'a> {
      pub accounts: MakeAccounts<'a>,
      pub instruction_data: MakeInstructionData,
      pub bump: u8,
  }

  impl<'a> TryFrom<(&'a [u8], &'a [AccountInfo])> for Make<'a> {
      type Error = ProgramError;

      fn try_from((data, accounts): (&'a [u8], &'a [AccountInfo])) -> Result<Self, Self::Error> {
          let accounts = MakeAccounts::try_from(accounts)?;
          let instruction_data = MakeInstructionData::try_from(data)?;

          // Initialize the escrow account
          let (escrow_key, bump) = find_program_address(&[b"escrow", accounts.maker.key(), &instruction_data.seed.to_le_bytes()], &crate::ID);
          if &escrow_key != accounts.escrow.key() {
              return Err(ProgramError::InvalidAccountOwner);
          }

          let seed_binding = instruction_data.seed.to_le_bytes();
          let bump_binding = [bump];
          let escrow_seeds = [
              Seed::from(b"escrow"),
              Seed::from(accounts.maker.key().as_ref()),
              Seed::from(&seed_binding),
              Seed::from(&bump_binding),
          ];

          ProgramAccount::init::<Escrow>(
              accounts.maker,
              accounts.escrow,
              &escrow_seeds,
              Escrow::LEN
          )?;

          // Initialize the vault
          AssociatedTokenAccount::init(
              accounts.vault,
              accounts.mint_a,
              accounts.maker,
              accounts.escrow,
              accounts.system_program,
              accounts.token_program,
          )?;

          Ok(Self {
              accounts,
              instruction_data,
              bump,
          })
      }
  }

  impl<'a> Make<'a> {
      pub const DISCRIMINATOR: &'a u8 = &0;

      pub fn try_new(
          accounts: MakeAccounts<'a>,
          instruction_data: MakeInstructionData,
      ) -> Result<Self, ProgramError> {
          // Initialize the escrow account
          let (escrow_key, bump) = find_program_address(&[b"escrow", accounts.maker.key(), &instruction_data.seed.to_le_bytes()], &crate::ID);
          if &escrow_key != accounts.escrow.key() {
              return Err(ProgramError::InvalidAccountOwner);
          }

          let seed_binding = instruction_data.seed.to_le_bytes();
          let bump_binding = [bump];
          let escrow_seeds = [
              Seed::from(b"escrow"),
              Seed::from(accounts.maker.key().as_ref()),
              Seed::from(&seed_binding),
              Seed::from(&bump_binding),
          ];

          ProgramAccount::init::<Escrow>(
              accounts.maker,
              accounts.escrow,
              &escrow_seeds,
              Escrow::LEN
          )?;

          // Initialize the vault
          AssociatedTokenAccount::init(
              accounts.vault,
              accounts.mint_a,
              accounts.maker,
              accounts.escrow,
              accounts.system_program,
              accounts.token_program,
          )?;

          Ok(Self {
              accounts,
              instruction_data,
              bump,
          })
      }

      pub fn process(&mut self) -> ProgramResult {
          // Populate the escrow account
          let mut data = self.accounts.escrow.try_borrow_mut_data()?;
          let escrow = unsafe { &mut *(data.as_mut_ptr() as *mut Escrow) };

          escrow.set_inner(
              self.instruction_data.seed,
              *self.accounts.maker.key(),
              *self.accounts.mint_a.key(),
              *self.accounts.mint_b.key(),
              self.instruction_data.receive,
              [self.bump],
          );

          // Transfer tokens to vault
          Transfer {
              from: self.accounts.maker_ata_a,
              to: self.accounts.vault,
              authority: self.accounts.maker,
              amount: self.instruction_data.amount
          }.invoke()?;

          Ok(())
      }
  }
  ```
</Codeblock>

<ArticleSection name="Take" id="take" level="h2" />

The `take` instruction finalizes the swap:
- Close the escrow record, sending its rent lamports back to the maker.
- Move Token A from the vault to the taker, then close the vault.
- Move the agreed amount of Token B from the taker to the maker.

### Required Accounts

Similarly these are all the accounts needed for the `Take` context:

Below are the accounts the context needs:

- taker: the person that wants to take the deal. Must be a signer and mutable.
- maker: the creator of the escrow. Must be mutable.
- escrow: the escrow account that we're initializing. Must be mutable.
- mint_a: the token we're depositing in the escrow
- mint_b: the token we want to receive
- vault: the associated token account owned by the escrow. Must be mutable
- taker_ata_a: the associated token account owned by the taker for mint_a. Must be mutable
- maker_ata_b: the associated token account owned by the maker for mint_b. Must be mutable
- taker_ata_b: the associated token account owned by the taker for mint_b. Must be mutable
- associated_token_program: the associated token program. Must be executable
- token_program: the token program. Must be executable
- system_program: the system program. Must be executable

And we perform these checks on it:

<Codeblock lang="rust">
  ```rust
  pub struct TakeAccounts<'a> {
      pub taker: &'a AccountInfo,
      pub maker: &'a AccountInfo,
      pub escrow: &'a AccountInfo,
      pub mint_a: &'a AccountInfo,
      pub mint_b: &'a AccountInfo,
      pub vault: &'a AccountInfo,
      pub taker_ata_a: &'a AccountInfo,
      pub taker_ata_b: &'a AccountInfo,
      pub maker_ata_b: &'a AccountInfo,
      pub system_program: &'a AccountInfo,
      pub token_program: &'a AccountInfo,
  }

  impl<'a> TryFrom<&'a [AccountInfo]> for TakeAccounts<'a> {
      type Error = ProgramError;

      fn try_from(accounts: &'a [AccountInfo]) -> Result<Self, Self::Error> {
          let [taker, maker, escrow, mint_a, mint_b, vault, taker_ata_a, taker_ata_b, maker_ata_b, system_program, token_program, _] = accounts else {
              return Err(ProgramError::NotEnoughAccountKeys);
          };

          // Basic Accounts Checks
          SignerAccount::check(taker)?;
          ProgramAccount::check(escrow)?;
          MintInterface::check(mint_a)?;
          MintInterface::check(mint_b)?;
          AssociatedTokenAccount::check(taker_ata_b, taker, mint_b, token_program)?;
          AssociatedTokenAccount::check(vault, escrow, mint_a, token_program)?;

          // Return the accounts
          Ok(Self {
              taker,
              maker,
              escrow,
              mint_a,
              mint_b,
              taker_ata_a,
              taker_ata_b,
              maker_ata_b,
              vault,
              system_program,
              token_program,
          })
      }
  }
  ```
</Codeblock>

### Instruction Data

All the data that we need to perform the logic already lives in the Escrow account or on the accounts that we're deserializing. For this reason we don't need any `instruction_data` for this instruction.

### Logic

Now we can move to the logic side of things. This time, we're going to put all the account initialization into our `try_from` function, just like we did before.

After that, we're going to handle PDA derivation verification in the `process()` function, transfer the funds from the vault to the taker, transfer the funds from the taker to the maker, and finally close both the vault and the escrow program account since we don't need them anymore.

<Codeblock lang="rust">
  ```rust
  pub struct Take<'a> {
      pub accounts: TakeAccounts<'a>,
  }

  impl<'a> Take<'a> {
      pub const DISCRIMINATOR: &'a u8 = &1;

      pub fn process(&mut self) -> ProgramResult {
          let escrow = unsafe { Escrow::from_account_info_unchecked(self.accounts.escrow)? };

          // Check if the escrow is valid
          let escrow_key = create_program_address(&[b"escrow", self.accounts.maker.key(), &escrow.seed().to_le_bytes(), escrow.bump()], &crate::ID)?;
          if &escrow_key != self.accounts.escrow.key() {
              return Err(ProgramError::InvalidAccountOwner);
          }

          let seed_binding = escrow.seed().to_le_bytes();
          let bump_binding = escrow.bump();

          let escrow_seeds = [
              Seed::from(b"escrow"),
              Seed::from(self.accounts.maker.key().as_ref()),
              Seed::from(&seed_binding),
              Seed::from(bump_binding),
          ];
          let signer = Signer::from(&escrow_seeds);

          let amount = self.accounts.vault.try_borrow_data()?[64..72].try_into().map(u64::from_le_bytes).unwrap();

          // Transfer from the Vault to the Taker
          Transfer {
              from: self.accounts.vault,
              to: self.accounts.taker_ata_a,
              authority: self.accounts.escrow,
              amount,
          }.invoke_signed(&[signer.clone()])?;

          // Close the Vault
          CloseAccount {
              account: self.accounts.vault,
              destination: self.accounts.maker,
              authority: self.accounts.escrow,
          }.invoke_signed(&[signer.clone()])?;

          // Transfer from the Taker to the Maker
          Transfer {
              from: self.accounts.taker_ata_b,
              to: self.accounts.maker_ata_b,
              authority: self.accounts.taker,
              amount: *escrow.receive(),
          }.invoke()?;

          // Close the Escrow
          ProgramAccount::close(self.accounts.escrow, self.accounts.taker)?;

          Ok(())
      }
  }
  ```
</Codeblock>

<ArticleSection name="Refund" id="refund" level="h2" />

The `refund` instruction lets the maker cancel an open offer:
- Close the escrow PDA and send its rent lamports back to the maker.
- Move the full Token A balance out of the vault and back to the maker, then close the vault account.

### Required Account

Knowing that this are the required accounts:

- maker: the creator of the escrow. Must be a signer and mutable
- escrow: the escrow account that we're initializing. Must be mutable
- mint_a: the token we're depositing in the escrow
- mint_b: the token we want to receive
- maker_ata_a: the associated token account owned by the maker. Must be mutable
- vault: the associated token account owned by the escrow. Must be mutable
- associated_token_program: the associated token program. Must be executable
- token_program: the token program. Must be executable
- system_program: the system program. Must be executable

We're going to let you create your own account structu since now you should be familiar with the process.

### Instruction Data

All the data that we need to perform the logic already lives in the Escrow account or on the accounts that we're deserializing. For this reason we don't need any `instruction_data` for this instruction.

### Logic

Here again, we're going to let you spread your wings and create your own logic for this! Don't be scared to go back to the previous sections to see how we implemented the make and take instruction, or reach out on Discord if you get stuck.


