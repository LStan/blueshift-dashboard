import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Transaction Request

Transaction requests unlock the full power of Solana Pay by enabling dynamic, server-composed transactions that can handle any type of Solana operation. Unlike transfer requests that contain all payment information in the URL, transaction requests use interactive endpoints to build custom transactions based on real-time data and business logic.

<ArticleSection name="Core Functionalities" id="core-functionalities" level="h2" />

Transaction requests follow a simple URL format that points to your server endpoint:

```
solana:<link>
```

The `link` value should be a URL to your API endpoint that can handle both `GET` and `POST` requests. When a user scans a transaction request QR code or clicks a link, their wallet initiates a four-step process that transforms a simple URL into a fully composed transaction ready for signing:
- Sends a GET request to retrieve display information like your business name and logo.
- Sends a POST request containing the user's public key. 
- Your server builds a custom transaction using this information and responds with a base64-encoded serialized transaction. 
- The wallet presents this transaction to the user for approval and signing.

> You can include query parameters, like amount and reference, in the URL to access it from your endpoint like this: `solana:<link>?<query_parameters>`.

<ArticleSection name="The API Endpoint" id="the-api-endpoint" level="h2" />

Creating a transaction request endpoint requires handling both GET and POST requests at the same URL. Using Next.js App Router as an example, you'll create a route.ts file in your `app/api/pay` folder:

```ts
import { NextRequest, NextResponse } from 'next/server';

// CORS headers for wallet compatibility
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

export async function OPTIONS() {
  return new NextResponse(null, { status: 200, headers: corsHeaders });
}

export async function GET() {
  // Implementation details below...
}

export async function POST(request: NextRequest) {
  // Implementation details below...
}
```

> Since wallets make cross-origin requests to your endpoint, CORS headers are mandatory. Without them, wallet requests will fail with CORS errors.

### GET Request

When wallets encounter a transaction request URL, they first issue a `GET` request to gather display information. Your endpoint should return a `JSON` object containing a label that describes your business or service, and an icon URL for visual branding:

```ts
export async function GET() {
  return NextResponse.json({
    label: "Coffee Shop Demo",
    icon: "https://solana.com/src/img/branding/solanaLogoMark.svg",
  }, { headers: corsHeaders });
}
```

The response will look like this:

```json
{
  "label": "Coffee Shop Demo",
  "icon": "https://solana.com/src/img/branding/solanaLogoMark.svg"
}
```

This information helps the user understand what they're about to interact with before proceeding to the actual transaction composition.

### POST Request

The `POST` request handler is where transaction requests truly shine. Your endpoint receives the user's public key and any query parameters from the original URL, then builds a completely custom transaction:

```ts
export async function POST(request: NextRequest) {
  // Parse user's public key from request body
  const body = await request.json();
  const { account } = body;

  // Connect to Solana network
  const connection = new Connection(clusterApiUrl("devnet"));
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();

  // Create transaction with user as fee payer
  const transaction = new Transaction({
    feePayer: new PublicKey(account),
    blockhash: blockhash,
    lastValidBlockHeight: lastValidBlockHeight,
  });

  // ========================================
  // ADD YOUR CUSTOM INSTRUCTIONS HERE
  // ========================================
  
  // This is where you build your transaction logic.
  // You can add any combination of instructions:
  
  // Example 1: Simple SOL transfer
  // const transferInstruction = SystemProgram.transfer({
  //   fromPubkey: new PublicKey(account),
  //   toPubkey: new PublicKey("YOUR_MERCHANT_WALLET"),
  //   lamports: LAMPORTS_PER_SOL * 0.01, // 0.01 SOL
  // });
  // transaction.add(transferInstruction);

  // Serialize the transaction for the wallet
  const serializedTransaction = transaction.serialize({
    requireAllSignatures: false,
    verifySignatures: false,
  });

  return NextResponse.json({
    transaction: serializedTransaction.toString('base64'),
    message: "Transaction created successfully", // Customize this message
  }, { headers: corsHeaders });
}
```

> Your application doesn't submit the transaction to the network so you won't have access to the transaction signature for tracking purposes. You can use reference as explained in the [Introduction Lesson](/en/courses/solana-pay/introduction#reference)

<ArticleSection name="QR Code Generation" id="qr-code-generation" level="h2" />

Transform any transaction request into a scannable QR code using the` @solana/pay library`:

```ts
import { createQR, encodeURL, TransactionRequestURLFields } from '@solana/pay'; 

const urlParams: TransactionRequestURLFields = {
  link: new URL("https://yourapi.com/pay"),
};
const solanaUrl = encodeURL(urlParams);

const qr = createQR(
  solanaUrl,
  400,
  "transparent"
);
```

<ArticleSection name="Advanced Features" id="advanced-features" level="h2" />

### Gated Transactions

Transaction requests enable sophisticated access control by letting you verify conditions before building transactions. Since you control the endpoint, you can check NFT ownership, whitelist membership, or any other criteria:

```ts
// Check NFT ownership before building transaction
const nfts = await metaplex.nfts().findAllByOwner({ owner: account }).run(); 

const hasRequiredNFT = nfts.some(nft => 
  nft.collection?.address.toString() === requiredCollection
);

if (!hasRequiredNFT) {
  return response.status(403).json({ 
    error: "Access denied: Required NFT not found" 
  });
}

// Build transaction only for verified users
```

### Partial Signing for Enhanced Security

For transactions requiring approval from an admin keypair or multi-party authentication, Solana Pay supports partial signing. Your server can add its signature to a transaction before sending it to the user's wallet:

```ts
const transaction = new Transaction({
  feePayer: account,
  blockhash,
  lastValidBlockHeight,
});

// Add your instructions requiring admin signature
transaction.add(customInstruction);

// Partially sign with your admin keypair
transaction.partialSign(adminKeypair);

// Send to user for final signature
const serializedTransaction = transaction.serialize({
  requireAllSignatures: false,
});
```