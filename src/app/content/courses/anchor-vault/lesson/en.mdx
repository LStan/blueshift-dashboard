
import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../components/Codeblock/Codeblock";

# Chapter 1: The Vault

![Image Test](/graphics/anchor-101.png)

In this first lesson you’ll get your Anchor workspace running and ship your first Solana program. Don't worry, we're going to hold your hand through all the steps needed.

<ArticleSection name="Anchor 101" id="anchor-101" level="h2" />

### What is Anchor

Anchor is the premier framework for Solana smart-contract development, offering a complete workflow for writing, testing, deploying, and interacting with onchain programs.

### Key advantages

- **Reduced boilerplate**: Anchor abstracts the repetitive work of account management, instruction serialization, and error handling so you can focus on just the core business logic.
- **Built-in security**:  Rigorous checks such as account-ownership verification and data validation run out of the box, mitigating many common vulnerabilities before they surface.

### Anchor Macros

- `declare_id!()`: Declares at what onchain address the program lives.
- `#[program]`: Marks the module that contains every instruction entrypoint and business-logic function.
- `#[derive(Accounts)]`: Lists the accounts an instruction requires and enforces their constraints automatically.
- `#[error_code]`: Defines custom, human-readable error types that make debugging clearer and faster.

Together, these declarative macros abstract away low-level byte management, allowing you to deliver secure, production-grade Solana programs with far less effort.

Let’s begin with a bare-bones version of the `Vault` program that we're going to build later in this section to explain in detail what each macro actually does:

<Codeblock lang="rust">
    ```rust
    declare_id!("22222222222222222222222222222222222222222222");

    #[program]
    pub mod blueshift_anchor_vault {
        use super::*;

        pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
            // ...
            Ok(())
        }

        pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
            // ...
            Ok(())
        }
    }

    #[derive(Accounts)]
    pub struct VaultAction<'info> {
        // ...
    }

    #[error_code]
    pub enum VaultError {
        // ...
    }
    ```
</Codeblock>

#### `declare_id!()`

The `declare_id!()` macro assigns to your program its onchain address; a unique public key derived from the keypair in the project’s `target` folder. That keypair signs and deploys the compiled `.so` binary containing all program logic and data.

**Note:** We use the placeholder `222222…` in Blueshift examples because of our internal test suite. In production, Anchor will generate a fresh program ID for you when you run the standard build and deploy commands.

#### `#[program]` & `#[derive(Accounts)]`

Every instruction has its own **Context** struct that lists all the accounts and, optionally, any data the instruction will need.  

In this example, both `deposit` and `withdraw` share the same accounts; for that reason, we're going to create a single account struct called `VaultAction` to keep things more efficient and easy.

#### A closer look at `#[derive(Accounts)]` macro

```rust
#[derive(Accounts)]
pub struct VaultAction<'info> {
  #[account(mut)]
  pub signer: Signer<'info>,

  #[account(
    mut,
    seeds = [b"vault", signer.key().as_ref()],
    bump,
  )]
  pub vault: SystemAccount<'info>,

  pub system_program: Program<'info, System>,
}
```

As we can see from the code snippet, the `#[derive(Accounts)]` macro serves three critical responsibilities:
- Declares all the accounts a specific instruction needs.
- Enforce constraint checks automatically, blocking many bugs and potential exploits at runtime.
- Generates helper methods that let you access and mutate accounts safely.

It accomplishes this through a combination of account types and inline attributes.

**Account types in our example**
- `Signer<'info>`: Verifies the account signed the transaction; essential for security and for CPIs that demand a signature.
- `SystemAccount<'info>`: Confirms ownership of the account by the System Program.
- `Program<'info, System>`: Ensures the account is executable and matches the System Program ID, enabling CPIs such as account creation or lamport transfers.

**Inline attributes you’ll encounter**
- `mut`: Flags the account as mutable; mandatory whenever its lamport balance or data may change.
- `seeds & bump`: Verifies the account is a Program-Derived Address (PDA) generated from the provided seeds plus a bump byte.

**Note** PDAs are important because:
- When used by the program that owns them, PDAs can sign CPIs on the program’s behalf.
- They give you deterministic, verifiable addresses for persisting program state.

#### `#[error_code]`

The `#[error_code]` macro lets you define clear, custom errors inside the program.

```rust
#[error_code]
pub enum VaultError {
    #[msg("Vault already exists")]
    VaultAlreadyExists,
    #[msg("Invalid amount")]
    InvalidAmount,
}
```

Each enum variant can carry a `#[msg(...)]` attribute that logs a descriptive string whenever the error occurs; far more helpful than a raw numeric code during debugging.

<ArticleSection name="The Vault" id="the-vault" />

Now that we’ve covered the key macros and account anatomy, it’s time to write the actual instruction logic. But before that, let's talk about how would the logic looks like: 

A vault, at its core, lets someone deposit lamports that only that same user can withdraw later. Our deposit and withdraw functions implement exactly that.

Before you begin, be sure Rust and Anchor are installed (see the [official documentation](https://www.anchor-lang.com/docs/installation) if you need a refresher). Then in your terminal run:

```
anchor init blueshift_anchor_vault
```

Open the newly generated folder, and you’re ready to start coding!

<ArticleSection name="Template" id="template" level="h3" />

Start by dropping in this scaffold in your `lib.rs`

```rust
declare_id!("22222222222222222222222222222222222222222222");

#[program]
pub mod blueshift_anchor_vault {
    use super::*;

    pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
        // ...
        Ok(())
    }

    pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
        // ...
        Ok(())
    }
}

#[derive(Accounts)]
pub struct VaultAction<'info> {
    // ...
}

#[error_code]
pub enum VaultError {
    // ...
}
```

<ArticleSection name="Deposit" id="deposit" level="h3" />

Here’s what happens in the `deposit` logic:
- Verifies the vault currently holds zero lamports (it must not already exist).
- Ensures the deposit amount exceeds the rent-exempt minimum for a SystemAccount.
- Transfers lamports from the signer to the vault via a CPI to the System Program.

```rust
pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
    require_eq!(ctx.accounts.vault.lamports(), 0, VaultError::VaultAlreadyExists);
    require_gt!(amount, Rent::get()?.minimum_balance(0), VaultError::InvalidAmount);


    transfer(
        CpiContext::new(ctx.accounts.system_program.to_account_info(), 
            Transfer {
                from: ctx.accounts.signer.to_account_info(),
                to: ctx.accounts.vault.to_account_info(),
            }
        ),
        amount,
    )?;

    Ok(())
}
```

The two `require_*` macros act like custom guard clauses:
- `require_eq!` confirms the vault is empty (preventing double deposits).
- `require_gt!` checks the amount clears the rent-exempt threshold.

Once the checks pass, Anchor’s System-Program helper calls the `Transfer` CPI:

```rust 
use anchor_lang::system_program::{transfer, Transfer};

transfer(
    CpiContext::new(ctx.accounts.system_program.to_account_info(), 
        Transfer {
            from: ctx.accounts.signer.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
        }
    ),
    amount,
)?;
```

This Anchor helper makes it super easy by creating a `CpiContext` specifying the System Program and the relevant from and to accounts, then execute the transfer by passing in the amount of lamports we want to transfer.

<ArticleSection name="Withdraw" id="withdraw" level="h3" />

Here’s what happens in the `withdraw` logic:
- Uses the vault’s PDA to sign the transfer out of the vault on its own behalf.
- Transfers all lamports in the vault back to the signer.

```rust
pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
    let bindings = ctx.accounts.signer.key();
    let signer_seeds = &[b"vault", bindings.as_ref(), &[ctx.bumps.vault]];

    transfer(
        CpiContext::new_with_signer(ctx.accounts.system_program.to_account_info(), 
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.signer.to_account_info(),
            },
            &[&signer_seeds[..]]
        ),
        ctx.accounts.vault.lamports(),
    )?;

    Ok(())
}
```

No extra require_ checks are needed here—ownership and balance validation are already baked into the VaultAction context. 

For example, we know the vault being withdrawn from is “owned” by the signer due to how the Program Derived Address (PDA) seeds are generated since part of those seeds includes the signer’s key. If this vault was funded previously, that same signer can withdraw whatever lamports were deposited.

As mentioned earlier, PDAs have “signer” capabilities within the same program they’re derived from. In this case, we use the signer’s public key to verify ownership of the vault, but the PDA itself “signs” the transfer. To do this, we:
- Create `signer_seeds`, an array of references to all the seeds used to derive the PDA.
- Pass these seeds into `CpiContext::new_with_signer`, allowing the PDA to act as the signer for this CPI call.

Everything else is exactly like the deposit, but in reverse. This time, we’re withdrawing all the lamports from the vault, sending them back to the signer.
