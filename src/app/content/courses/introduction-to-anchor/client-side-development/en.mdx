import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Client Side Development

Most dApp, will use typescript to interact with the program you deployed. For this reason, it's important to know how to integrate your program client side.

<ArticleSection name="Anchor Client SDK" id="anchor-client-sdk" level="h2" />

Anchor simplifies client interaction with Solana programs by providing an Interface Description Language (IDL) file that reflects the program's structure.

Using the IDL with Anchor's TypeScript library (@coral-xyz/anchor) provides a streamlined format for building instructions and transactions.

### Setup

The `@coral-xyz/anchor` package is automatically installed when creating an Anchor program. After running `anchor build`, Anchor generates an IDL at `target/idl/<program-name>.json` and a TypeScript SDK at `target/types/<program-name>.ts` that abstracts away much of the complexity.

You can then transfer them into a TypeScript client that interacts with an Anchor program, that usually is structured this way:

```
src
├── anchor
│     ├── <program-name>.json
│     └── <program-name>.ts
└── integration.ts
```

> The `integration.ts` file contains all logic for interacting with the smart contract. The `<program-name>.json` file is the IDL, and `<program-name>.ts` contains the generated TypeScript types.

To use the wallet adapter with the Anchor TypeScript SDK, create an Anchor `Provider` object. The `Provider` combines the `Connection` (localhost, devnet, or mainnet) and the `Wallet` (the address used to pay for and sign transactions).

Start by setting up the `Wallet` and `Connection`:

```ts
import { useAnchorWallet, useConnection } from "@solana/wallet-adapter-react";

const { connection } = useConnection();
const wallet = useAnchorWallet();
```

> The `useWallet` hook from `@solana/wallet-adapter-react` is incompatible with the `Wallet` object that the Anchor `Provider` expects. Use the `useAnchorWallet` hook instead.

Now create the Provider object and set it as the default provider using `setProvider`:

```
import { AnchorProvider, setProvider } from "@coral-xyz/anchor";

const provider = new AnchorProvider(connection, wallet, {
  commitment: "confirmed",
});

setProvider(provider);
```

### Program

Anchor provides a `Program` object that creates a custom API for interacting with Solana programs.

This API serves as the central interface for all onchain program communication:
- Send transactions, 
- Fetch deserialized accounts, 
- Decode instruction data, 
- Subscribe to account changes, 
- Listen to events

Create the `Program` object by importing the types and IDL:

```ts
import <program-name> from "./<program-name>.json";
import type { <Program-Type> } from "./<program-name>.ts";
import { Program, Idl } from "@coral-xyz/anchor";

const program = new Program(<program-name> as <Program-Type>);
```

If you haven't set a default provider, specify it explicitly:

```ts
const program = new Program(<program-name> as <Program-Type>, provider);
```

Once the `Program` object is configured, use the Anchor Methods Builder to construct instructions and transactions for the program.

The `MethodsBuilder` uses the IDL to provide a streamlined format for building transactions that invoke program instructions.

The basic `MethodsBuilder` format follows this pattern:

```ts
await program.methods
  .instructionName(instructionDataInputs)
  .accounts({})
  .signers([])
  .rpc();
```

> The API uses camel case naming convention instead of the snake case convention typical for Rust, and simply calls the instruction using dot syntax with the instruction's name, passing any instruction arguments as comma-separated values.

If additional signers are required by the instruction beyond the provider, pass them using the `.signers()` call.

### Accounts

On the `MethodsBuilder`, use dot syntax to call `.accounts`, passing an object with each account the instruction expects based on the IDL.

> From Anchor 0.30.0, accounts that can be "resolved" automatically, like PDAs or explicit addresses, are added to the IDL and are not required in the `.accounts` call (`.accountPartial()` becomes the default account resolution). To pass all accounts manually, use the `.accountsStrict()` call.

### Transactions 

The default method for sending transactions through Anchor is using the `.rpc()` call that directly sends the transaction to the chain.

Sometimes, for example when creating a transaction on the frontend using the user's wallet and needing to safely sign the transaction with a keypair held in the backend, use the `.transaction()` call that creates a transaction to be signed later:

```ts
const transaction = await program.methods
  .instructionName(instructionDataInputs)
  .accounts({})
  .transaction();

//... Sign the transaction in the backend

// Send the transaction to the chain
await sendTransaction(transaction, connection);
```

To bundle multiple Anchor instructions, use the `.instruction()` call to get an instruction object to add to the transaction:

```ts
// creates first instruction
const instructionOne = await program.methods
  .instructionOneName(instructionOneDataInputs)
  .accounts({})
  .instruction();

// creates second instruction
const instructionTwo = await program.methods
  .instructionTwoName(instructionTwoDataInputs)
  .accounts({})
  .instruction();

// add both instruction to one transaction
const transaction = new Transaction().add(instructionOne, instructionTwo);

// send transaction
await sendTransaction(transaction, connection);
```

<ArticleSection name="Fetch and Filter Accounts" id="fetch-and-filter-accounts" level="h2" />

Once your program creates hundreads of accounts, it becomes hard to keep track of all of them. Luckily the `Program` object also allows you to easily fetch and filter all program accounts.

You can fetch all addresses of a specific account in your program by doing:

```ts
const accounts = await program.account.counter.all();
```

If you want specific accounts out of all of these, you can create filters using the `memcmp` flag like this:

```ts
const accounts = await program.account.counter.all([
  {
    memcmp: {
      offset: 8,
      bytes: bs58.encode(new BN(0, "le").toArray()),
    },
  },
]);
```

> This fetches all the `Counter` accounts with 0 as the first field.

Alternatively, for example when checking if the account data actually changed, you can get the deserialized account data for a specific account using `fetch` if you know the address of the account you're looking for:

```ts
const account = await program.account.counter.fetch(ACCOUNT_ADDRESS);
```

Similarly, you can fetch multiple accounts using `fetchMultiple`:

```ts
const accounts = await program.account.counter.fetchMultiple([
  ACCOUNT_ADDRESS_ONE,
  ACCOUNT_ADDRESS_TWO,
]);
```

<ArticleSection name="Events and Webhooks" id="events-and-webhooks" level="h2" />

Most of the time, as a developer, you don't want to fetch onchain data every time a user logs in with their wallet. For this reason, it's fundamental to set up systems that listen to the blockchain and save the data you need in a database.

There are two main ways of listening to on-chain events:
- Polling
- Streaming

Polling is a method where the client or application repeatedly checks a server or data source for new data at set intervals or on-demand. When a request is sent to the server, it responds with the latest data, whether or not there has been any change. This means the client may receive the same data repeatedly, even if there has been no update.

Streaming is a technique where the server pushes data to the client when there is an update. The client does not need to request data repeatedly, and the server only sends data when there is a change. This results in more efficient and real-time data transfer, as the server sends only relevant data.

To stream your Anchor instructions, you can use webhooks. Webhooks listen to events and send them to a server you've set up when they happen. For example, you might want to change a database entry whenever an NFT sale happens on your marketplace: a webhook can accomplish this seamlessly.

> For extremely low latency use cases where a 5ms difference might make or break your application, you shouldn't use webhooks.

Anchor provides two macros for emitting events in your programs:
- `emit!()`: emits events directly to program logs using the `sol_log_data()` syscall and encoding the event data as a `base64` string prefixed with "Program Data"
- `emit_cpi!()`: emits events through Cross Program Invocations (CPIs) to the program itself. The event data is encoded and included in the CPI's instruction data (instead of program logs)

### `emit!()` macro

This is how the `emit!()` macro looks like in your program:

```rust
use anchor_lang::prelude::*;
 
declare_id!("8T7MsCZyzxboviPJg5Rc7d8iqEcDReYR2pkQKrmbg7dy");
 
#[program]
pub mod event {
    use super::*;
 
    pub fn emit_event(_ctx: Context<EmitEvent>, input: String) -> Result<()> {
        emit!(CustomEvent { message: input });
        Ok(())
    }
}
 
#[derive(Accounts)]
pub struct EmitEvent {}
 
#[event]
pub struct CustomEvent {
    pub message: String,
}
```

Since the event data is base64 encoded, to make it readable, the Anchor SDK has helpers that we can use like this:

```ts
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Event } from "../target/types/event";
 
describe("event", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
 
  const program = anchor.workspace.Event as Program<Event>;
 
  it("Emits custom event", async () => {
    // Set up listener before sending transaction
    const listenerId = program.addEventListener("customEvent", event => {
      // Do something with the event data
      console.log("Event Data:", event);
    });
  });
});
```

### `emit_cpi!()` macro

This is how the `emit_cpi!()` macro looks in your program:

```rust
use anchor_lang::prelude::*;
 
declare_id!("2cDQ2LxKwQ8fnFUz4LLrZ157QzBnhPNeQrTSmWcpVin1");
 
#[program]
pub mod event_cpi {
    use super::*;
 
    pub fn emit_event(ctx: Context<EmitEvent>, input: String) -> Result<()> {
        emit_cpi!(CustomEvent { message: input });
        Ok(())
    }
}
 
#[event_cpi]
#[derive(Accounts)]
pub struct EmitEvent {}
 
#[event]
pub struct CustomEvent {
    pub message: String,
}
```

And on the client side:

```ts
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { EventCpi } from "../target/types/event_cpi";
 
describe("event-cpi", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.EventCpi as Program<EventCpi>;
 
  it("Emits custom event", async () => { 
    // Fetch the transaction data
    const transactionData = await program.provider.connection.getTransaction(
      transactionSignature,
      { commitment: "confirmed" },
    );
 
    // Decode the event data from the CPI instruction data
    const eventIx = transactionData.meta.innerInstructions[0].instructions[0];
    const rawData = anchor.utils.bytes.bs58.decode(eventIx.data);
    const base64Data = anchor.utils.bytes.base64.encode(rawData.subarray(8));
    const event = program.coder.events.decode(base64Data);

    console.log(event);
  });
});
```