# Assembly Memo

![Image Test](/graphics/asm-memo.png)

## Introduction
sBPF Assembly is a human-readable, 1:1 representation of the eBPF bytecode that all Solana programs compile down to. It is not typically used for most onchain development, however it is essential for extreme optimization. 

High-level languages often lack the expressiveneto to rigidly define desired behavior, forcing compilers to make conservative assumptions at the cost of performance.

### Compilation

To give you an example, let's start with a highly optimized `noop` program written in Pinocchio:

```rust
#![no_std]
use pinocchio::{entrypoint::InstructionContext, lazy_program_entrypoint, no_allocator, nostd_panic_handler, ProgramResult};

lazy_program_entrypoint!(process_instruction);

nostd_panic_handler!();
no_allocator!();

fn process_instruction(
    _context: InstructionContext, // wrapper around the input buffer
 ) -> ProgramResult {
    Ok(())
}
```

If we build this code with `cargo build-sbf --dump`, we will get an ELF dump that gives us information about our binary in the `/target/deploy/` directory. We will then want to look for the `.text` section; the part of our binary where executable code is stored.

```pinocchio_noop-dump.txt
Disassembly of section .text

0000000000000120 <entrypoint>
     120 b7 00 00 00 00 00 00 00      	mov64 r0, 0x0
     128 95 00 00 00 00 00 00 00      	exit
```

### Disassembly

If we were to disassemble the binary to turn it back into compilable sBPF Assembly, the code would look like this:

```sbpf
.globl entrypoint:
    mov64 r0, 0x00
    exit
```

This is an extremely small program, with just 3 lines of code, only 2 instructions, or "insns" (We sometimes refer to an sBPF instruction as an `insn` to delinneate between bytecode instructions and transaction instructions) and just `2 CUs` to execute.

Let's break down what each line does:

1. `.globl entrypoint:` tells the linker that this is the offset of our program entrypoint in the binary. This is interpreted by the runtime to where it should start executing sBPF `insns` from.
2. `mov64 r0, 0x00` sets the value of `r0` (register zero) to `0x00`. `r0` is our return register, and setting it to zero indicates successful program execution.
3. `exit` tells the runtime we can now exit the program, taking the current value of `r0` as our execution result.


If we think about it, this actually maps very logically to our Rust code. We told the compiler:
1. This is our entrypoint function
2. Expect it to return a `ProgramResult` which evaluates to a numeric value
3. Return `Ok(())` which evaluates to `0x00`

As such, the above bytecode is actually a very reasonable interpretation by the compiler of our desired logic, but it is still not quite optimal. 

### Optimization

It would be possible to simplify our compiled code down to just:

```sbpf
.globl entrypoint:
    exit
```

This would make the program cost just `1 CU` to execute. A saving of 50%. This is because in the Solana runtime, `r0` is instantiated to `0x00` by default, so it does not need to be explicitly set to `0x00` unless it has previously been overwritten with another value. This is what we mean when we say the compiler lacks context.

Fortunately, we have the ability both to write our own assembly, and to lean on the compiler to get us very close to good bytecode before disassembling and optimizing out the pieces we don't need in there. 

## Assembly 101
In this lesson, we will familiarize you with some of the basic concepts you'll need to understand to write assembly, such as `directives`, `registers` and `opcodes`. 

### Directives

There are a bunch of Assembly directives, each of which are used to tell the assembler to do something. Here are some practical examples of a few that you'll likely see when writing assembly or disassembling binaries:

1. `.globl` - declares a symbol and tells the assembler to expose it to the linker
2. `.section .text` - tells the assembler to store anything in this section in the text section, where our program insns are stored 
3. `.section .rodata` - tells the assembler to store anything in this section in the read-only data section
4. `.ascii` - declares an ASCII string to be consumed by the program
5. `.equ` - declares a numeric value that can be consumed inline for offsets.

### Registers

The Solana runtime has 10 general purpose registers, `r0`-`r9`. Some have specific behaviors that we won't go into now, but the most important thing to understand is that `r0` is our return register. If `r0` is set to any value other than `0x00` it will be treated as an error code. If `r0` is set to `0x00` by the end of program execution, it will be treated as a `success` code.

Registers are used to store one of two things:

1. A typed value like a `u8`, `u16`, `u32` or `u64`.
2. A reference to some segment of data

Upon instantiation of the VM, `r0` is instantiated to `0x00` by default and `r1` is instantiated with a pointer to the start of our serialized entrypoint data, which consists of:

1. Number of `Accounts`
2. Serialized `Account` data + reallocation padding
3. `Instruction Data` length
4. `Instruction Data`
5. `Program ID`

If you wish to dump the assembly of a program, there is an open source tool called `sbpf`.


### OP Codes
OP Codes have several fucntions, such as storing and loading data and arithmetic.

## Assembly Memo
