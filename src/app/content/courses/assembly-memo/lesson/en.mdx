# Assembly Memo

![Anchor Memo course banner](/graphics/banners/assembly-memo.png)

<ArticleSection name="Assembly 101" id="assembly-101" level="h2" />

sBPF assembly is a 1:1, human-readable view of the eBPF byte-code every Solana program ultimately runs. You rarely need to touch it, but when you’re chasing optimization, or you simply want to know exactly what the VM is doing, these fundamentals help.

High-level Rust can’t always express every micro-optimisation, so the compiler sometimes leaves safe, but slower code. Reading (or writing) assembly gives you total control.

In this unit we’ll cover:
- Instruction format: how a single 8-byte slot is laid out
- Directives: assembler hints like `.section` and `.equ`
- Registers: what the ten GPRs, frame pointer, and stack pointer do
- Opcodes: the verb list the VM understands

#### Instructions

When you compile Rust (or C/assembly) the tool-chain emits a stream of fixed-width, 8-byte instructions and packs them into the .text section of your ELF.

Think of it as a tiny fixed-width struct that the VM can decode in one pass:

```
   1 byte    4 bits   4 bits     2 bytes         4 bytes
┌──────────┬────────┬────────┬──────────────┬──────────────────┐
│  opcode  │  dst   │  src   │   offset     │      imm         │
└──────────┴────────┴────────┴──────────────┴──────────────────┘
```

- `opcode`: It says what kind of work this instruction represents. Top 3 bits choose the class: arithmetic, memory, jump, call, exit. Lower 5 bits pick the exact variant (e.g. add, mul, ldxdw, jeq).
- `dst`: The “destination” register number (r0 – r9). Whatever the instruction produces; like an arithmetic result, a loaded value, a helper return—lands here.
- `src`: The “source” register. For two-operand arithmetic (add r1, r2) it supplies the second input. For memory ops it can carry the base address you’re loading from or storing to. For ALU-immediate variants (add r1, 10) these 4 bits are folded into the opcode, so src isn’t used.
- `offset`: A small integer that modifies the instruction’s behaviour: On loads/stores it’s added to src to reach [src + offset]. On jumps it’s a relative branch target measured in instructions (not bytes).
- `imm`: Arithmetic ops use it for immediate math (add r1, 42). CALL uses it as the helper/syscall number (sol_log = 16). Memory ops often treat it as an absolute pointer or additional stride.

```
add64   r1, 5            ; r1 = r1 + 5          (opcode uses imm, no src reg)
ldxdw   r2, [r1 + 12]    ; r2 = *(u64*)(r1+12)  (src = r1, dst = r2, offset = 12)
jeq     r2, 0, +3        ; if r2 == 0, jump 3   (imm = 0, offset = +3 insns)
call    16               ; sol_log(...)         (imm = helper ID 16)
exit                     ; return r0
```

Each line above is eight bytes wide; each holds exactly those five fields. Once you recognise the pattern: `verb`, `dst`, `src`, `offset`, `imm`; you can skim any disassembly and know what’s happening without hunting through variable-length encodings.

### Directives

Assembler directives tell the assembler where to put things or how to label them.

Here are some practical examples of a few that you'll likely see when writing assembly or disassembling binaries:

1. `.globl` [symbol]: Makes a symbol visible to the linker (e.g. `entrypoint`).
2. `.section .text`: Place following bytes in the code section where our program insns are stored
3. `.section .rodata`: Place read-only data (consts, strings) here.
4. `.ascii` ["hello"]: Emit a ASCII string.
5. `.equ` [CONST 42]: Create a numeric constant for offsets or flags.

### Registers

The Solana runtime has 10 general purpose registers:
- `r0` holds the function’s return data.
- `r1`-`r5` store function arguments, and `r5` can actually store “spillover” data, which is represented by a pointer to some stack data.
- `r6`-`r9` are call-preserved registers, which means that their values are preserved across function calls.

Since `r0` holds the return data, if it's set to any value other than `0x00` it will be treated as an error code.

Upon instantiation of the VM, `r0` is instantiated to `0x00` by default and `r1` is instantiated with a pointer to the start of our serialized entrypoint data, which consists of:
1. Number of `Accounts`
2. Serialized `Account` data + reallocation padding
3. `Instruction Data` length
4. `Instruction Data`
5. `Program ID`

<ArticleSection name="Example" id="example" level="h2" />

Now that we know the basic sBPF operations, let’s see what they look like in a real (albeit tiny) program.

Below is a high-performance “noop” written with Pinocchio. All it does is return success.

```rust
#![no_std]
use pinocchio::{entrypoint::InstructionContext, lazy_program_entrypoint, no_allocator, nostd_panic_handler, ProgramResult};

lazy_program_entrypoint!(process_instruction);

nostd_panic_handler!();
no_allocator!();

fn process_instruction(
    _context: InstructionContext, // wrapper around the input buffer
 ) -> ProgramResult {
    Ok(())
}
```

If we build this code with `cargo build-sbf --dump`, we will get an ELF dump that gives us information about our binary in the `/target/deploy/` directory.

We will then want to look for the `.text` section; the part of our binary where executable code is stored.

```pinocchio_noop-dump.txt
Disassembly of section .text

0000000000000120 <entrypoint>
     120 b7 00 00 00 00 00 00 00      	mov64 r0, 0x0
     128 95 00 00 00 00 00 00 00      	exit
```

### Disassembly

If we were to disassemble the binary to turn it back into compilable sBPF Assembly, the code would look like this:

```sbpf
.globl entrypoint:
    mov64 r0, 0x00   ; r0 <- success
    exit             ; finish, return r0
```

This is an extremely small program, with just 3 lines of code, only 2 instructions, or "insns" (We sometimes refer to an sBPF instruction as an `insn` to delinneate between bytecode instructions and transaction instructions) and just `2 CUs` to execute.

Let's break down what each line does:

1. `.globl entrypoint:` tells the linker that this is the offset of our program entrypoint in the binary. This is interpreted by the runtime to where it should start executing sBPF `insns` from.
2. `mov64 r0, 0x00` sets the value of `r0` (register zero) to `0x00`. `r0` is our return register, and setting it to zero indicates successful program execution.
3. `exit` tells the runtime we can now exit the program, taking the current value of `r0` as our execution result.


If we think about it, this actually maps very logically to our Rust code. We told the compiler:
1. This is our entrypoint function
2. Expect it to return a `ProgramResult` which evaluates to a numeric value
3. Return `Ok(())` which evaluates to `0x00`

As such, the above bytecode is actually a very reasonable interpretation by the compiler of our desired logic, but it is still not quite optimal.

### Optimization

It would be possible to simplify our compiled code down to just:

```sbpf
.globl entrypoint:
    exit
```

This would make the program cost just `1 CU` to execute. A saving of 50%. This is because in the Solana runtime, `r0` is instantiated to `0x00` by default, so it does not need to be explicitly set to `0x00` unless it has previously been overwritten with another value. This is what we mean when we say the compiler lacks context.

Fortunately, we have the ability both to write our own assembly, and to lean on the compiler to get us very close to good bytecode before disassembling and optimizing out the pieces we don't need in there.

<ArticleSection name="The Memo Program" id="memo-program" level="h2" />

Now let's look at the simplicity of a bite-size memo program written straight in sBPF assembly.

All it does is print the instruction data to the Solana log and return success.

```
.equ NUM_ACCOUNTS, 0x00;
.equ DATA_LEN, 0x08;
.equ DATA, 0x10;

.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]
  ldxdw r2, [r1+DATA_LEN]
  add64 r1, DATA
  call sol_log_
  exit
```

We begin by declaring three `.equ` constants: NUM_ACCOUNTS, DATA_LEN, and DATA.

Each marks the byte-offset (relative to the entry-buffer pointer in `r1`) for:
- the account count field,
- the instruction data length, and
- the instruction data bytes themselves.

```
ldxdw r0, [r1+NUM_ACCOUNTS]   ; r0 ← number-of-accounts
```

As we said before, `r0` is the register the VM reads on exit: `0` means success, any non-zero value is treated as an error code.

To optimize a check, that we want to perform on the account count field, we can load it directly into `r0` guaranteing the program will fail automatically if the instruction passes any account (because the value would be non-zero).

```
ldxdw r2, [r1+DATA_LEN]   ; r2 ← length of memo
add64  r1, DATA           ; r1 ← pointer to memo bytes
```

We then prepare the arguments for the `sol_log_` syscall:

The sBPF helper calls can pass up to five arguments in registers `r1`–`r5`.

In this case, `sol_log_` expects:
- arg 1 (r1): pointer to the bytes to print
- arg 2 (r2): length of those bytes

The two instructions above load exactly those values into the right slots.

```
call 16   ; helper ID 16 = sol_log_
exit      ; return, using whatever is still in r0
```

We then call the helper using 16 as the `ID` to print the memo to the validator log, and we end the program using the `exit` call.

Since we haven't changed `r0` after step 1, a “memo with zero accounts” exits with success (`r0` = 0), while a memo that sneaks in any account exits with a non-zero error.